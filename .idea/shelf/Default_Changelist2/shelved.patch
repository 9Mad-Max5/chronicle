Index: app/src/main/res/drawable/ic_delete.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/res/drawable/ic_delete.xml b/app/src/main/res/drawable/ic_delete.xml
new file mode 100755
--- /dev/null	(date 1601489494172)
+++ b/app/src/main/res/drawable/ic_delete.xml	(date 1601489494172)
@@ -0,0 +1,5 @@
+<vector android:height="24dp" android:tint="#FFFFFF"
+    android:viewportHeight="24" android:viewportWidth="24"
+    android:width="24dp" xmlns:android="http://schemas.android.com/apk/res/android">
+    <path android:fillColor="@android:color/white" android:pathData="M6,19c0,1.1 0.9,2 2,2h8c1.1,0 2,-0.9 2,-2V7H6v12zM19,4h-3.5l-1,-1h-5l-1,1H5v2h14V4z"/>
+</vector>
Index: app/src/main/java/io/github/mattpvaughn/chronicle/data/sources/demo/DemoMediaSource.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/io/github/mattpvaughn/chronicle/data/sources/demo/DemoMediaSource.kt b/app/src/main/java/io/github/mattpvaughn/chronicle/data/sources/demo/DemoMediaSource.kt
new file mode 100755
--- /dev/null	(date 1601491459480)
+++ b/app/src/main/java/io/github/mattpvaughn/chronicle/data/sources/demo/DemoMediaSource.kt	(date 1601491459480)
@@ -0,0 +1,123 @@
+package io.github.mattpvaughn.chronicle.data.sources.demo
+
+import android.content.Context
+import android.graphics.Bitmap
+import android.graphics.BitmapFactory
+import android.net.Uri
+import com.google.android.exoplayer2.upstream.AssetDataSource
+import com.google.android.exoplayer2.upstream.DataSource
+import com.google.android.exoplayer2.upstream.DataSpec
+import io.github.mattpvaughn.chronicle.R
+import io.github.mattpvaughn.chronicle.data.model.Audiobook
+import io.github.mattpvaughn.chronicle.data.model.MediaItemTrack
+import io.github.mattpvaughn.chronicle.data.sources.MediaSource
+import io.github.mattpvaughn.chronicle.navigation.Navigator
+import timber.log.Timber
+import java.io.IOException
+import kotlin.time.ExperimentalTime
+import kotlin.time.seconds
+
+
+class DemoMediaSource(
+    override val id: Long,
+    private val applicationContext: Context
+) : MediaSource(applicationContext) {
+
+    private val draculaAudioAssetPath = "file:///android_asset/dracula_short.mp3"
+    private val draculaArtAssetPath = "file:///android_asset/cover_small.jpg"
+
+    override val name: String
+        get() = "Demo Library"
+
+    override val icon: Int
+        get() = R.drawable.ic_library_music
+
+    private val assetDataSource = AssetDataSource(applicationContext).apply {
+        val dataSpec = DataSpec(Uri.parse(draculaAudioAssetPath))
+        try {
+            open(dataSpec)
+        } catch (e: AssetDataSource.AssetDataSourceException) {
+            Timber.e(e)
+        }
+    }
+
+    override val dataSourceFactory: DataSource.Factory = DataSource.Factory { assetDataSource }
+
+    @ExperimentalTime
+    private val audiobooks = listOf(
+        Audiobook(
+            id = 1,
+            source = id,
+            title = "Dracula (first minute)",
+            titleSort = "Dracula (first minute)",
+            author = "Bram Stoker",
+            duration = 75.seconds.toLongMilliseconds(),
+            isCached = true,
+            thumb = draculaArtAssetPath
+        )
+    )
+
+    @ExperimentalTime
+    private val tracks = listOf(
+        // sole track for demo book 1
+        MediaItemTrack(
+            id = 2,
+            parentKey = 1,
+            title = "Intro",
+            playQueueItemID = 1,
+            index = 1,
+            duration = 75.seconds.toLongMilliseconds(),
+            album = "Dracula (first minute)",
+            artist = "Bram Stoker",
+            cached = true
+        )
+    )
+
+    @ExperimentalTime
+    override suspend fun fetchBooks(): Result<List<Audiobook>> {
+        return Result.success(audiobooks)
+    }
+
+    @ExperimentalTime
+    override suspend fun fetchTracks(): Result<List<MediaItemTrack>> {
+        return Result.success(tracks)
+    }
+
+
+    /** No setup to do, just brings the user home */
+    override fun setup(navigator: Navigator) {
+        navigator.showHome()
+    }
+
+    override fun type(): String {
+        return TAG
+    }
+
+    override fun makeThumbUri(src: String): Uri? {
+        return Uri.parse(draculaArtAssetPath)
+    }
+
+    override fun getBitmapForThumb(uri: Uri): Bitmap? {
+        Timber.i("Getting demo bitmap")
+        return try {
+            val stream = applicationContext.assets.open(draculaArtAssetPath)
+            BitmapFactory.decodeStream(stream)
+        } catch (e: IOException) {
+            // handle exception
+            Timber.i("Failed to get demo bitmap")
+            null
+        }
+    }
+
+    override fun getTrackSource(track: MediaItemTrack): Uri? {
+        return Uri.parse(draculaAudioAssetPath)
+    }
+
+    // false as it's already on device
+    override val isDownloadable: Boolean
+        get() = false
+
+    companion object {
+        const val TAG = "DemoMediaSource"
+    }
+}
\ No newline at end of file
Index: app/src/main/java/io/github/mattpvaughn/chronicle/data/sources/plex/PlexPrefsRepo.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/io/github/mattpvaughn/chronicle/data/sources/plex/PlexPrefsRepo.kt b/app/src/main/java/io/github/mattpvaughn/chronicle/data/sources/plex/PlexPrefsRepo.kt
new file mode 100755
--- /dev/null	(date 1601391975357)
+++ b/app/src/main/java/io/github/mattpvaughn/chronicle/data/sources/plex/PlexPrefsRepo.kt	(date 1601391975357)
@@ -0,0 +1,216 @@
+package io.github.mattpvaughn.chronicle.data.sources.plex
+
+import android.annotation.SuppressLint
+import android.content.SharedPreferences
+import com.squareup.moshi.Moshi
+import io.github.mattpvaughn.chronicle.data.model.PlexLibrary
+import io.github.mattpvaughn.chronicle.data.model.ServerModel
+import io.github.mattpvaughn.chronicle.data.sources.plex.model.Connection
+import io.github.mattpvaughn.chronicle.data.sources.plex.model.MediaType
+import io.github.mattpvaughn.chronicle.data.sources.plex.model.PlexUser
+import java.util.*
+import javax.inject.Inject
+import kotlin.collections.HashSet
+
+/** A interface for Plex exclusive preferences */
+interface PlexPrefsRepo {
+    /**
+     * The active auth token for the active account/profile. A 20ish character string. Defaults to
+     * empty string "" if user is not signed in
+     */
+    var accountAuthToken: String
+
+    /** The active user profile */
+    var user: PlexUser?
+
+    /** The active plex library */
+    var library: PlexLibrary?
+
+    /** Reference to the connected server */
+    var server: ServerModel?
+
+    /**
+     * Temporary id used by oAuth to identify the client. Provided by the server. Only valid for
+     * a few minutes so no strong need to clear it after login
+     */
+    var oAuthTempId: Long
+
+    /** Unique user id */
+    val uuid: String
+
+    /** Clear all preferences which are handled by PrefsRepo */
+    fun clear()
+}
+
+/** An implementation of [PlexPrefsRepo] wrapping [SharedPreferences]. */
+class SharedPreferencesPlexPrefsRepo @Inject constructor(
+    private val prefs: SharedPreferences,
+    private val moshi: Moshi
+) : PlexPrefsRepo {
+
+    private companion object {
+        const val PREFS_AUTH_TOKEN_KEY = "auth_token"
+        const val PREFS_LIBRARY_NAME_KEY = "library_name"
+        const val PREFS_LIBRARY_ID_KEY = "library_id"
+        const val PREFS_SERVER_NAME_KEY = "server_name"
+        const val PREFS_SERVER_ACCESS_TOKEN = "server_token"
+        const val PREFS_SERVER_IS_OWNED = "server_owned"
+        const val PREFS_SERVER_ID_KEY = "server_id"
+        const val PREFS_REMOTE_SERVER_CONNECTIONS_KEY = "remote_server_connections"
+        const val PREFS_USER = "user"
+        const val PREFS_LOCAL_SERVER_CONNECTIONS_KEY = "local_server_connections"
+        const val PREFS_UUID_KEY = "uuid"
+        const val PREFS_TEMP_ID = "id"
+        const val NO_TEMP_ID_FOUND = -1L
+    }
+
+    override val uuid: String
+        @SuppressLint("ApplySharedPref")
+        get() {
+            var tempUUID = getString(PREFS_UUID_KEY, "")
+            if (tempUUID.isEmpty()) {
+                val generatedUUID = UUID.randomUUID().toString()
+                prefs.edit().putString(PREFS_UUID_KEY, generatedUUID).commit()
+                tempUUID = generatedUUID
+            }
+            return tempUUID
+        }
+
+    override var accountAuthToken: String
+        get() = getString(PREFS_AUTH_TOKEN_KEY)
+        @SuppressLint("ApplySharedPref")
+        set(value) {
+            prefs.edit().putString(PREFS_AUTH_TOKEN_KEY, value).commit()
+        }
+
+    override var user: PlexUser?
+        get() {
+            val userString = prefs.getString(PREFS_USER, "")
+            if (userString.isNullOrEmpty()) {
+                return null
+            }
+            return moshi.adapter<PlexUser>(PlexUser::class.java).fromJson(userString)
+        }
+        @SuppressLint("ApplySharedPref")
+        set(value) {
+            if (value == null) {
+                prefs.edit().remove(PREFS_USER).commit()
+                return
+            }
+            val userString = moshi.adapter<PlexUser>(PlexUser::class.java).toJson(value)
+            prefs.edit().putString(PREFS_USER, userString).commit()
+        }
+
+    override var library: PlexLibrary?
+        get() {
+            val name = getString(PREFS_LIBRARY_NAME_KEY)
+            val id = getString(PREFS_LIBRARY_ID_KEY)
+            if (name.isEmpty() || id.isEmpty()) {
+                return null
+            }
+            return PlexLibrary(name, MediaType.ARTIST, id)
+        }
+        @SuppressLint("ApplySharedPref")
+        set(value) {
+            if (value == null) {
+                prefs.edit()
+                    .remove(PREFS_LIBRARY_ID_KEY)
+                    .remove(PREFS_LIBRARY_NAME_KEY).commit()
+                return
+            }
+            prefs.edit()
+                .putString(PREFS_LIBRARY_NAME_KEY, value.name)
+                .putString(PREFS_LIBRARY_ID_KEY, value.id).commit()
+        }
+
+    override var server: ServerModel?
+        get() {
+            val name = getString(PREFS_SERVER_NAME_KEY)
+            val id = getString(PREFS_SERVER_ID_KEY)
+            val token: String = getString(PREFS_SERVER_ACCESS_TOKEN)
+            val owned: Boolean = prefs.getBoolean(PREFS_SERVER_IS_OWNED, true)
+
+            val connections = getServerConnections()
+
+            if (name.isEmpty() || token.isEmpty() || connections.isEmpty()) {
+                return null
+            }
+
+            return ServerModel(name, connections, id, token, owned)
+        }
+        @SuppressLint("ApplySharedPref")
+        set(value) {
+            if (value == null) {
+                prefs.edit()
+                    .remove(PREFS_SERVER_ID_KEY)
+                    .remove(PREFS_SERVER_ACCESS_TOKEN)
+                    .remove(PREFS_SERVER_IS_OWNED)
+                    .remove(PREFS_LOCAL_SERVER_CONNECTIONS_KEY)
+                    .remove(PREFS_REMOTE_SERVER_CONNECTIONS_KEY)
+                    .remove(PREFS_SERVER_NAME_KEY).commit()
+                return
+            }
+            prefs.edit()
+                .putString(PREFS_SERVER_NAME_KEY, value.name)
+                .putString(PREFS_SERVER_ID_KEY, value.serverId)
+                .putString(PREFS_SERVER_ACCESS_TOKEN, value.accessToken)
+                .putBoolean(PREFS_SERVER_IS_OWNED, value.owned).commit()
+            putConnections(value.connections)
+        }
+
+    private fun getServerConnections(): List<Connection> {
+        val localServers = getStringSet(PREFS_LOCAL_SERVER_CONNECTIONS_KEY).toList()
+        val remoteServers = getStringSet(PREFS_REMOTE_SERVER_CONNECTIONS_KEY).toList()
+
+        val combinedList = (localServers union remoteServers).toList()
+        return combinedList.map { Connection(it) }
+    }
+
+
+    // TODO: ensure this is only usable for a certain amount of time
+    override var oAuthTempId: Long
+        get() = prefs.getLong(PREFS_TEMP_ID, NO_TEMP_ID_FOUND)
+        @SuppressLint("ApplySharedPref")
+        set(value) {
+            prefs.edit().putLong(PREFS_TEMP_ID, value).commit()
+        }
+
+    override fun clear() {
+        server = null
+        library = null
+        user = null
+        accountAuthToken = ""
+    }
+
+    @SuppressLint("ApplySharedPref")
+    private fun putConnections(connections: List<Connection>) {
+        prefs.edit()
+            .putStringSet(
+                PREFS_LOCAL_SERVER_CONNECTIONS_KEY,
+                connections.map { connection -> connection.uri }.toSet()
+            )
+            .putStringSet(
+                PREFS_REMOTE_SERVER_CONNECTIONS_KEY,
+                connections.map { connection -> connection.uri }.toSet()
+            ).commit()
+    }
+
+    private fun getStringSet(key: String): MutableSet<String> {
+        return prefs.getStringSet(key, HashSet<String>()) ?: HashSet()
+    }
+
+    /**
+     * Retrieve a string stored in shared preferences
+     *
+     * @param key the key of the item stored in preferences
+     * @param defaultValue (optional) the value to return if the desired string cannot be found.
+     *                     Defaults to the empty string
+     *
+     * @return the stored preference value corresponding to the [key] passed in. If there is no
+     * corresponding value, return the default value provided
+     *
+     */
+    private fun getString(key: String, defaultValue: String = ""): String {
+        return prefs.getString(key, defaultValue) ?: defaultValue
+    }
+}
Index: app/src/main/java/io/github/mattpvaughn/chronicle/data/sources/plex/PlexLibrarySource.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/io/github/mattpvaughn/chronicle/data/sources/plex/PlexLibrarySource.kt b/app/src/main/java/io/github/mattpvaughn/chronicle/data/sources/plex/PlexLibrarySource.kt
new file mode 100755
--- /dev/null	(date 1601499364064)
+++ b/app/src/main/java/io/github/mattpvaughn/chronicle/data/sources/plex/PlexLibrarySource.kt	(date 1601499364064)
@@ -0,0 +1,546 @@
+package io.github.mattpvaughn.chronicle.data.sources.plex
+
+import android.app.DownloadManager
+import android.content.Context
+import android.content.Context.MODE_PRIVATE
+import android.graphics.Bitmap
+import android.net.Uri
+import android.os.Build
+import androidx.lifecycle.LiveData
+import androidx.lifecycle.MutableLiveData
+import com.bumptech.glide.Glide
+import com.bumptech.glide.load.engine.DiskCacheStrategy
+import com.bumptech.glide.load.model.LazyHeaders
+import com.bumptech.glide.load.resource.bitmap.CenterCrop
+import com.google.android.exoplayer2.upstream.DefaultDataSourceFactory
+import com.google.android.exoplayer2.upstream.DefaultHttpDataSourceFactory
+import com.squareup.moshi.Moshi
+import io.github.mattpvaughn.chronicle.BuildConfig
+import io.github.mattpvaughn.chronicle.R
+import io.github.mattpvaughn.chronicle.application.Injector
+import io.github.mattpvaughn.chronicle.data.APP_NAME
+import io.github.mattpvaughn.chronicle.data.ConnectionState
+import io.github.mattpvaughn.chronicle.data.ConnectionState.*
+import io.github.mattpvaughn.chronicle.data.model.*
+import io.github.mattpvaughn.chronicle.data.sources.HttpMediaSource
+import io.github.mattpvaughn.chronicle.data.sources.MediaSource
+import io.github.mattpvaughn.chronicle.data.sources.plex.IPlexLoginRepo.LoginState.LOGGED_IN_NO_SERVER_CHOSEN
+import io.github.mattpvaughn.chronicle.data.sources.plex.IPlexLoginRepo.LoginState.LOGGED_IN_NO_USER_CHOSEN
+import io.github.mattpvaughn.chronicle.data.sources.plex.PlexLibrarySource.ConnectionResult.Failure
+import io.github.mattpvaughn.chronicle.data.sources.plex.PlexLibrarySource.ConnectionResult.Success
+import io.github.mattpvaughn.chronicle.data.sources.plex.model.*
+import io.github.mattpvaughn.chronicle.navigation.Navigator
+import io.github.mattpvaughn.chronicle.views.GlideUrlRelativeCacheKey
+import kotlinx.coroutines.*
+import okhttp3.OkHttpClient
+import okhttp3.internal.userAgent
+import okhttp3.logging.HttpLoggingInterceptor
+import retrofit2.Retrofit
+import retrofit2.converter.moshi.MoshiConverterFactory
+import timber.log.Timber
+import java.io.File
+import java.net.URL
+import java.util.concurrent.TimeUnit
+import kotlin.random.Random
+
+/** A [MediaSource] responsible for interacting with a remote Plex library */
+class PlexLibrarySource constructor(
+    override val id: Long,
+    applicationContext: Context,
+    loggingInterceptor: HttpLoggingInterceptor,
+    moshi: Moshi
+) : HttpMediaSource(applicationContext) {
+
+    private val connectionSet = mutableSetOf<Connection>()
+
+    var url: String = PLACEHOLDER_URL
+
+    private val _connectionState = MutableLiveData<ConnectionState>(NOT_CONNECTED)
+    override val connectionState: LiveData<ConnectionState>
+        get() = _connectionState
+
+    val sessionIdentifier = Random.nextInt(until = 10000).toString()
+
+    /** Prepends the current server url to [relativePathForResource], accounting for trailing/leading `/`s */
+    override fun toServerString(relativePathForResource: String): String {
+        val baseEndsWith = url.endsWith('/')
+        val pathStartsWith = relativePathForResource.startsWith('/')
+        return if (baseEndsWith && pathStartsWith) {
+            "$url/${relativePathForResource.substring(1)}"
+        } else if (!baseEndsWith && !pathStartsWith) {
+            "$url/$relativePathForResource"
+        } else {
+            "$url$relativePathForResource"
+        }
+    }
+
+    override val name: String
+        get() = plexPrefsRepo.library?.name.takeIf { !it.isNullOrEmpty() } ?: "Plex library"
+
+    override val icon: Int
+        get() = R.drawable.ic_plex_library_white
+
+    private val plexPrefsRepo: PlexPrefsRepo = SharedPreferencesPlexPrefsRepo(
+        applicationContext.getSharedPreferences(id.toString(), MODE_PRIVATE),
+        moshi
+    )
+
+    private val httpFactory = DefaultHttpDataSourceFactory(userAgent)
+
+    // Handles http and local files
+    override val dataSourceFactory: DefaultDataSourceFactory =
+        DefaultDataSourceFactory(Injector.get().applicationContext(), httpFactory)
+
+
+    private val plexMediaInterceptor = PlexInterceptor(plexPrefsRepo, this, isLoginService = false)
+    private val plexLoginInterceptor = PlexInterceptor(plexPrefsRepo, this, isLoginService = true)
+
+    private val mediaOkHttpClient = OkHttpClient.Builder()
+        .connectTimeout(15, TimeUnit.SECONDS)
+        .writeTimeout(15, TimeUnit.SECONDS)
+        .readTimeout(15, TimeUnit.SECONDS)
+        .addInterceptor(plexMediaInterceptor)
+        .addInterceptor(loggingInterceptor)
+        .build()
+
+    private val loginOkHttpClient = OkHttpClient.Builder()
+        .connectTimeout(15, TimeUnit.SECONDS)
+        .writeTimeout(15, TimeUnit.SECONDS)
+        .readTimeout(15, TimeUnit.SECONDS)
+        .addInterceptor(plexLoginInterceptor)
+        .addInterceptor(loggingInterceptor)
+        .build()
+
+    private val mediaRetrofit: Retrofit = Retrofit.Builder()
+        .addConverterFactory(MoshiConverterFactory.create())
+        .client(mediaOkHttpClient)
+        .baseUrl(PLACEHOLDER_URL) // this will be replaced by PlexInterceptor as needed
+        .build()
+
+    private val loginRetrofit: Retrofit = Retrofit.Builder()
+        .addConverterFactory(MoshiConverterFactory.create())
+        .client(loginOkHttpClient)
+        .baseUrl(PLACEHOLDER_URL) // this will be replaced by PlexInterceptor as needed
+        .build()
+
+    private val mediaService: PlexMediaService = mediaRetrofit.create(PlexMediaService::class.java)
+    private val loginService: PlexLoginService = loginRetrofit.create(PlexLoginService::class.java)
+
+    private val plexLoginRepo: PlexLoginRepo = PlexLoginRepo(plexPrefsRepo, loginService)
+
+    override suspend fun fetchBooks(): Result<List<Audiobook>> {
+        return try {
+            val libraryId = plexPrefsRepo.library?.id!!
+            val response = mediaService.retrieveAllAlbums(libraryId)
+            Result.success(response.plexMediaContainer.asAudiobooks(id))
+        } catch (t: Throwable) {
+            Result.failure(t)
+        }
+    }
+
+    override suspend fun fetchTracks(): Result<List<MediaItemTrack>> {
+        return try {
+            val response = mediaService.retrieveAllTracksInLibrary(plexPrefsRepo.library?.id!!)
+            Result.success(response.plexMediaContainer.asTrackList(id))
+        } catch (t: Throwable) {
+            Result.failure(t)
+        }
+    }
+
+    /** Launches Plex OAuth login process up to choosing library */
+    override fun setup(navigator: Navigator) {
+        TODO("Not yet implemented")
+    }
+
+    override fun type(): String {
+        return TAG
+    }
+
+    override fun getBitmapForThumb(uri: Uri): Bitmap? {
+        TODO("Not yet implemented")
+    }
+
+    override fun getTrackSource(track: MediaItemTrack): Uri? {
+        return Uri.parse(
+            if (track.cached) {
+                File(
+                    Injector.get().prefsRepo().cachedMediaDir,
+                    track.getCachedFileName()
+                ).absolutePath
+            } else {
+                toServerString(track.media)
+            }
+        )
+    }
+
+    override val isDownloadable: Boolean = true
+
+    /** Attempt to load in a cached bitmap for the given thumbnail */
+    suspend fun getBitmapFromServer(thumb: String?, requireCached: Boolean = false): Bitmap? {
+        if (thumb.isNullOrEmpty()) {
+            return null
+        }
+
+        // Retrieve cached album art from Glide if available
+        val appContext = Injector.get().applicationContext()
+        val imageSize = appContext.resources.getDimension(R.dimen.audiobook_image_width).toInt()
+        val url = URL(
+            if (thumb.startsWith("http")) {
+                thumb
+            } else {
+                Timber.i("Taking part uri")
+                toServerString("photo/:/transcode?width=$imageSize&height=$imageSize&url=$thumb")
+            }
+        )
+        Timber.i("Notification thumb uri is: $url")
+        val glideUrl = GlideUrlRelativeCacheKey(url, makeGlideHeaders())
+        return try {
+            return withContext(Dispatchers.IO) {
+                val bm = Glide.with(appContext)
+                    .asBitmap()
+                    .load(glideUrl)
+                    .onlyRetrieveFromCache(requireCached)
+                    .diskCacheStrategy(DiskCacheStrategy.ALL)
+                    .transform(CenterCrop())
+                    .submit()
+                    .get()
+                Timber.i("Successfully retrieved album art for $thumb")
+                bm
+            }
+        } catch (t: Throwable) {
+            // who cares?
+            Timber.e("Failed to retrieve album art for $thumb: $t")
+            null
+        }
+    }
+
+    override fun makeGlideHeaders(): LazyHeaders {
+        return LazyHeaders.Builder()
+            .addHeader(
+                "X-Plex-Token",
+                plexPrefsRepo.server?.accessToken ?: plexPrefsRepo.accountAuthToken
+            )
+            .build()
+    }
+
+    override suspend fun fetchChapterInfo(
+        isAudiobookCached: Boolean,
+        tracks: List<MediaItemTrack>
+    ): List<Chapter> {
+        return tracks.flatMap { track ->
+            val networkChapters = mediaService.retrieveChapterInfo(track.id)
+                .plexMediaContainer.metadata.firstOrNull()?.plexChapters
+            if (BuildConfig.DEBUG) {
+                // prevent networkChapters from toString()ing and being slow even if timber
+                // tree isn't attached in the release build
+                Timber.i("Network chapters: $networkChapters")
+            }
+            // If no chapters for this track, make a chapter from the current track
+            networkChapters?.map { plexChapter ->
+                plexChapter.toChapter(track.id.toLong(), track.discNumber, track.cached)
+            }.takeIf {
+                !it.isNullOrEmpty()
+            } ?: listOf(track.asChapter())
+        }.sorted()
+    }
+
+    suspend fun fetchLibraries(): PlexMediaContainerWrapper {
+        return mediaService.retrieveLibraries()
+    }
+
+    suspend fun fetchServers(): List<PlexServer> {
+        return loginService.resources()
+    }
+
+    suspend fun fetchUsersForAccount(): UsersResponse {
+        return loginService.getUsersForAccount()
+    }
+
+    suspend fun pickUser(uuid: String, pin: String): Result<PlexUser> {
+        return try {
+            val user = loginService.pickUser(uuid, pin)
+            Result.success(user)
+        } catch (t: Throwable) {
+            Result.failure(t)
+        }
+    }
+
+    override suspend fun updateProgress(
+        trackId: String,
+        trackProgress: String,
+        key: String,
+        duration: Long,
+        playState: String,
+        hasMde: Int,
+        playbackTime: Long,
+        playQueueItemId: Long
+    ) {
+        mediaService.progress(
+            ratingKey = trackId,
+            offset = trackProgress,
+            playbackTime = playbackTime,
+            playQueueItemId = playQueueItemId,
+            key = "${MediaItemTrack.PARENT_KEY_PREFIX}$trackId",
+            duration = duration,
+            playState = playState,
+            hasMde = 1
+        )
+    }
+
+    override suspend fun fetchTracksForBook(bookId: Int): List<MediaItemTrack> {
+        return mediaService.retrieveTracksForAlbum(bookId).plexMediaContainer.asTrackList(id)
+    }
+
+//    override suspend fun sendMediaSessionStartCommand() {
+//        TODO("Not yet implemented")
+//    }
+
+    override fun makeDownloadRequest(trackUrl: String): DownloadManager.Request {
+        Timber.i("Preparing download request for: ${Uri.parse(toServerString(trackUrl))}")
+        return DownloadManager.Request(Uri.parse(toServerString(trackUrl)))
+            .addRequestHeader("X-Plex-Platform", "Android")
+            .addRequestHeader("X-Plex-Provides", "player,timeline")
+            .addRequestHeader(
+                "X-Plex-Client-Name",
+                APP_NAME
+            )
+            .addRequestHeader("X-Plex-Client-Identifier", plexPrefsRepo.uuid)
+            .addRequestHeader("X-Plex-Version", BuildConfig.VERSION_NAME)
+            .addRequestHeader(
+                "X-Plex-Product",
+                APP_NAME
+            )
+            .addRequestHeader("X-Plex-Platform-Version", Build.VERSION.RELEASE)
+            .addRequestHeader("X-Plex-Device", Build.MODEL)
+            .addRequestHeader("X-Plex-Device-Name", Build.MODEL)
+            .addRequestHeader("X-Plex-Session-Identifier", sessionIdentifier)
+            .addRequestHeader(
+                "X-Plex-Token",
+                plexPrefsRepo.server?.accessToken ?: plexPrefsRepo.accountAuthToken
+            )
+    }
+
+    override fun makeThumbUri(thumb: String): Uri {
+        val appContext = Injector.get().applicationContext()
+        val imageSize = appContext.resources.getDimension(R.dimen.audiobook_image_width).toInt()
+        val plexThumbPart = "photo/:/transcode?width=$imageSize&height=$imageSize&url=$thumb"
+        val uri = Uri.parse(toServerString(plexThumbPart))
+        return uri.buildUpon()
+            .appendQueryParameter(
+                "X-Plex-Token",
+                plexPrefsRepo.server?.accessToken ?: plexPrefsRepo.accountAuthToken
+            ).build()
+    }
+
+    override fun refreshAuth() {
+        with(httpFactory.defaultRequestProperties) {
+            set("X-Plex-Platform", "Android")
+            set("X-Plex-Provides", "player")
+            set("X-Plex_Client-Name", APP_NAME)
+            set("X-Plex-Client-Identifier", plexPrefsRepo.uuid)
+            set("X-Plex-Version", BuildConfig.VERSION_NAME)
+            set("X-Plex-Product", APP_NAME)
+            set("X-Plex-Platform-Version", Build.VERSION.RELEASE)
+            set("X-Plex-Device", Build.MODEL)
+            set("X-Plex-Device-Name", Build.MODEL)
+            set("X-Plex-Token", plexPrefsRepo.server?.accessToken ?: plexPrefsRepo.accountAuthToken)
+        }
+
+    }
+
+    /**
+     * Indicates to observers that connectivity has been lost, but does not update URL yet, as
+     * querying a possibly dead url has a better chance of success than querying no url
+     */
+    override fun connectionHasBeenLost() {
+        _connectionState.value = NOT_CONNECTED
+    }
+
+    private var prevConnectToServerJob: CompletableJob? = null
+
+    @InternalCoroutinesApi
+    override suspend fun connectToRemote() {
+        connectionSet.clear()
+        connectionSet.addAll(plexPrefsRepo.server?.connections ?: emptyList())
+        prevConnectToServerJob?.cancel("Killing previous connection attempt")
+        _connectionState.postValue(CONNECTING)
+        prevConnectToServerJob = Job().also {
+            val context = CoroutineScope(it + Dispatchers.Main)
+            context.launch {
+                val connectionResult = chooseViableConnections(mediaService)
+                Timber.i("Returned connection $connectionResult")
+                if (connectionResult is Success && connectionResult.url != PLACEHOLDER_URL) {
+                    url = connectionResult.url
+                    _connectionState.postValue(CONNECTED)
+                    Timber.i("Connection success: $url")
+                } else {
+                    _connectionState.postValue(CONNECTION_FAILED)
+                }
+            }
+        }
+    }
+
+    /** Clear server data from [plexPrefsRepo] and [url] managed by [PlexLibrarySource] */
+    fun clear() {
+        plexPrefsRepo.clear()
+        _connectionState.postValue(NOT_CONNECTED)
+        url = PLACEHOLDER_URL
+        connectionSet.clear()
+    }
+
+    fun clearServer() {
+        _connectionState.postValue(NOT_CONNECTED)
+        url = PLACEHOLDER_URL
+        plexPrefsRepo.server = null
+        plexPrefsRepo.library = null
+    }
+
+    fun clearLibrary() {
+        plexPrefsRepo.library = null
+    }
+
+    fun clearUser() {
+        plexPrefsRepo.library = null
+        plexPrefsRepo.server = null
+        plexPrefsRepo.user = null
+    }
+
+    sealed class ConnectionResult {
+        data class Success(val url: String) : ConnectionResult()
+        object Failure : ConnectionResult()
+    }
+
+    /**
+     * Attempts to connect to all [Connection]s in [connectionSet] via
+     * [PlexMediaService.checkServer] (no auth required).
+     *
+     * On the first successful connection, return a [ConnectionResult.Success] with
+     *   [ConnectionResult.Success.url] from the [Connection.uri]
+     *
+     * If all connections fail: return a [Failure] as soon as all connections have completed
+     *
+     * If no connections are made within 15 seconds, return a [ConnectionResult.Failure].
+     */
+    @InternalCoroutinesApi
+    @OptIn(ExperimentalCoroutinesApi::class)
+    private suspend fun chooseViableConnections(plexMediaService: PlexMediaService): ConnectionResult {
+        return withTimeoutOrNull(15000) {
+            Timber.i("Choosing viable connection from: $connectionSet")
+            val connections = connectionSet.sortedByDescending { it.local }
+            val deferredConnections = connections.map { conn ->
+                async {
+                    Timber.i("Testing connection: ${conn.uri}")
+                    try {
+                        plexMediaService.checkServer(conn.uri)
+                        return@async Success(conn.uri)
+                    } catch (e: Throwable) {
+                        return@async Failure
+                    }
+                }
+            }
+
+            while (deferredConnections.any { it.isActive }) {
+                Timber.i("Connections: $deferredConnections")
+                deferredConnections.forEach { deferred ->
+                    if (deferred.isCompleted) {
+                        val completed = deferred.getCompleted()
+                        if (completed is Success) {
+                            Timber.i("Returning connection $completed")
+                            deferredConnections.forEach { it.cancel("Sibling completed, killing connection attempt: $it") }
+                            return@withTimeoutOrNull completed
+                        }
+                    }
+                }
+                delay(500)
+            }
+
+            // Check if the final completed job was a success
+            Timber.i("Connections: $deferredConnections")
+            deferredConnections.forEach { deferred ->
+                if (deferred.isCompleted && deferred.getCompleted() is Success) {
+                    Timber.i("Returning final completed connection ${deferred.getCompleted()}")
+                    return@withTimeoutOrNull deferred.getCompleted()
+                }
+            }
+
+            Timber.i("Returning connection $Failure")
+            Failure
+        } ?: Failure
+    }
+
+    fun chooseServer(serverModel: ServerModel) {
+        connectionSet.clear()
+        connectionSet.addAll(serverModel.connections)
+        plexLoginRepo.chooseServer(serverModel)
+    }
+
+    fun chooseUser(user: PlexUser) {
+        plexLoginRepo.chooseUser(user)
+    }
+
+    fun chooseLibrary(plexLibrary: PlexLibrary) {
+        plexLoginRepo.chooseLibrary(plexLibrary)
+    }
+
+    override fun isAuthorized(): Boolean {
+        return plexPrefsRepo.server?.accessToken != null && plexPrefsRepo.library != null
+    }
+
+    private var isAuthorizedLiveData = MutableLiveData<Boolean>(false)
+    override fun isAuthorizedObservable(): LiveData<Boolean> {
+        return isAuthorizedLiveData
+    }
+
+    override suspend fun watched(mediaKey: Int) {
+        mediaService.watched(mediaKey.toString())
+    }
+
+    suspend fun startMediaSession(bookId: String) {
+        val serverId = plexPrefsRepo.server?.serverId ?: ""
+        val serverUri = getMediaItemUri(serverId, bookId)
+        mediaService.startMediaSession(serverUri)
+    }
+
+    suspend fun postOAuthPin(): OAuthResponse? {
+        return plexLoginRepo.postOAuthPin()
+    }
+
+    fun makeOAuthUrl(id: String, code: String): Uri {
+        return plexLoginRepo.makeOAuthUrl(id, code)
+    }
+
+    suspend fun checkForOAuthAccessToken(navigator: Navigator): Result<IPlexLoginRepo.LoginState> {
+        val result = plexLoginRepo.checkForOAuthAccessToken()
+        if (result.isFailure) {
+            return result
+        }
+        when (result.getOrNull()) {
+            LOGGED_IN_NO_USER_CHOSEN -> {
+                // multiple users available- so show user chooser
+                navigator.showUserChooser()
+            }
+            LOGGED_IN_NO_SERVER_CHOSEN -> {
+                // only one user was available, so skipping directly to server picker
+                navigator.showServerChooser()
+            }
+            else -> {
+                return Result.failure(IllegalStateException("Impossible network state: neither NO_USERS_CHOSEN nor NO_SERVER_CHOSEN"))
+            }
+        }
+        return Result.success(result.getOrElse { IPlexLoginRepo.LoginState.FAILED_TO_LOG_IN })
+    }
+
+    companion object {
+        const val TAG = "PlexLibrarySource"
+
+        /**
+         * Creates a URI uniquely identifying a media item with id [mediaId] on a server with machine
+         * identifier [machineIdentifier]
+         */
+        fun getMediaItemUri(machineIdentifier: String, mediaId: String): String {
+            return "server://$machineIdentifier/com.plexapp.plugins.library/library/metadata/$mediaId"
+        }
+
+    }
+
+}
\ No newline at end of file
Index: app/src/main/java/io/github/mattpvaughn/chronicle/features/player/ChronicleMediaRepository.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/io/github/mattpvaughn/chronicle/features/player/ChronicleMediaRepository.kt b/app/src/main/java/io/github/mattpvaughn/chronicle/features/player/ChronicleMediaRepository.kt
new file mode 100755
--- /dev/null	(date 1601391975381)
+++ b/app/src/main/java/io/github/mattpvaughn/chronicle/features/player/ChronicleMediaRepository.kt	(date 1601391975381)
@@ -0,0 +1,40 @@
+package io.github.mattpvaughn.chronicle.features.player
+
+import android.support.v4.media.MediaMetadataCompat
+import androidx.lifecycle.LiveData
+import io.github.mattpvaughn.chronicle.data.local.IBookRepository
+import io.github.mattpvaughn.chronicle.data.model.Audiobook
+import io.github.mattpvaughn.chronicle.data.model.toAlbumMediaMetadata
+import javax.inject.Inject
+
+class ChronicleMediaRepository @Inject constructor(private val bookRepository: IBookRepository) :
+    AbstractMediaSource() {
+
+    private val bookIndex = 0
+    private lateinit var books: LiveData<List<Audiobook>>
+
+    override suspend fun load() {
+        books = bookRepository.getAllBooks()
+    }
+
+    override fun whenReady(performAction: (Boolean) -> Unit): Boolean {
+        performAction(true)
+        return true
+    }
+
+    // Needs to iterate over books and tracks
+    override fun iterator(): Iterator<MediaMetadataCompat> {
+        return object : Iterator<MediaMetadataCompat> {
+            override fun hasNext(): Boolean {
+                return bookIndex < (books.value?.size ?: 0) - 1
+            }
+
+            override fun next(): MediaMetadataCompat {
+                requireNotNull(books.value)
+                return books.value!![bookIndex].toAlbumMediaMetadata()
+            }
+
+        }
+    }
+}
+
Index: app/src/main/java/io/github/mattpvaughn/chronicle/features/sources/SourceManagerViewModel.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/io/github/mattpvaughn/chronicle/features/sources/SourceManagerViewModel.kt b/app/src/main/java/io/github/mattpvaughn/chronicle/features/sources/SourceManagerViewModel.kt
new file mode 100755
--- /dev/null	(date 1601899805064)
+++ b/app/src/main/java/io/github/mattpvaughn/chronicle/features/sources/SourceManagerViewModel.kt	(date 1601899805064)
@@ -0,0 +1,102 @@
+package io.github.mattpvaughn.chronicle.features.sources
+
+import androidx.lifecycle.*
+import io.github.mattpvaughn.chronicle.R
+import io.github.mattpvaughn.chronicle.data.local.IBookRepository
+import io.github.mattpvaughn.chronicle.data.local.ITrackRepository
+import io.github.mattpvaughn.chronicle.data.sources.MediaSource
+import io.github.mattpvaughn.chronicle.data.sources.MediaSource.Companion.NO_SOURCE_FOUND
+import io.github.mattpvaughn.chronicle.data.sources.SourceManager
+import io.github.mattpvaughn.chronicle.navigation.Navigator
+import io.github.mattpvaughn.chronicle.util.Event
+import io.github.mattpvaughn.chronicle.util.postEvent
+import kotlinx.coroutines.InternalCoroutinesApi
+import kotlinx.coroutines.launch
+import javax.inject.Inject
+
+
+@OptIn(InternalCoroutinesApi::class)
+class SourceManagerViewModel @Inject constructor(
+    private val sourceManager: SourceManager,
+    private val navigator: Navigator,
+    private val trackRepository: ITrackRepository,
+    private val bookRepository: IBookRepository
+) : ViewModel() {
+
+    fun addSource() {
+        navigator.addSource()
+    }
+
+    /** Deletes a [source] permanently if it exists */
+    fun removeSource() {
+        source.value?.id?.let { id ->
+            if (id == NO_SOURCE_FOUND) {
+                return@let
+            }
+            val result = sourceManager.removeSource(id)
+            viewModelScope.launch {
+                // TODO: Should be added to some sort of task to ensure completion. WorkManager?
+                if (result.isSuccess) {
+                    trackRepository.removeWithSource(id)
+                    bookRepository.removeWithSource(id)
+                }
+            }
+        }
+        _source.postValue(OptionalMediaSourceWrapper())
+    }
+
+    fun showErrorMessage(message: String) {
+        _userMessage.postEvent(message)
+    }
+
+    /** A light wrapper around [MediaSource] which provides default values if source is missing */
+    data class OptionalMediaSourceWrapper(val source: MediaSource? = null) {
+
+        val id = source?.id ?: NO_SOURCE_FOUND
+        val type = source?.type() ?: "No type"
+        val name = source?.name ?: "No source"
+        val icon = source?.icon ?: R.drawable.ic_library_music
+
+        val isEmpty = source == null
+
+    }
+
+    private val _source = MutableLiveData(OptionalMediaSourceWrapper())
+    val source: LiveData<OptionalMediaSourceWrapper>
+        get() = _source
+
+    fun showEditSource(source: MediaSource) {
+        _source.postValue(OptionalMediaSourceWrapper(source))
+    }
+
+    fun closeEditSource() {
+        _source.postValue(OptionalMediaSourceWrapper())
+    }
+
+    class Factory @Inject constructor(
+        private val sourceManager: SourceManager,
+        private val navigator: Navigator,
+        private val trackRepository: ITrackRepository,
+        private val bookRepository: IBookRepository
+    ) : ViewModelProvider.Factory {
+        @Suppress("UNCHECKED_CAST")
+        override fun <T : ViewModel> create(modelClass: Class<T>): T {
+            if (modelClass.isAssignableFrom(SourceManagerViewModel::class.java)) {
+                return SourceManagerViewModel(
+                    sourceManager,
+                    navigator,
+                    trackRepository,
+                    bookRepository
+                ) as T
+            }
+            throw IllegalArgumentException("Unknown ViewHolder class")
+        }
+    }
+
+    private val _userMessage = MutableLiveData<Event<String>>()
+    val userMessage: LiveData<Event<String>>
+        get() = _userMessage
+
+    val sources: LiveData<List<MediaSource>> = sourceManager.sourcesObservable
+
+}
\ No newline at end of file
Index: app/src/main/res/drawable/ic_folder_white.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/res/drawable/ic_folder_white.xml b/app/src/main/res/drawable/ic_folder_white.xml
new file mode 100755
--- /dev/null	(date 1601498991303)
+++ b/app/src/main/res/drawable/ic_folder_white.xml	(date 1601498991303)
@@ -0,0 +1,5 @@
+<vector android:height="24dp" android:tint="#FFFFFF"
+    android:viewportHeight="24" android:viewportWidth="24"
+    android:width="24dp" xmlns:android="http://schemas.android.com/apk/res/android">
+    <path android:fillColor="@android:color/white" android:pathData="M10,4H4c-1.1,0 -1.99,0.9 -1.99,2L2,18c0,1.1 0.9,2 2,2h16c1.1,0 2,-0.9 2,-2V8c0,-1.1 -0.9,-2 -2,-2h-8l-2,-2z"/>
+</vector>
Index: app/src/main/java/io/github/mattpvaughn/chronicle/features/sources/SourceManagerFragment.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/io/github/mattpvaughn/chronicle/features/sources/SourceManagerFragment.kt b/app/src/main/java/io/github/mattpvaughn/chronicle/features/sources/SourceManagerFragment.kt
new file mode 100755
--- /dev/null	(date 1601492852383)
+++ b/app/src/main/java/io/github/mattpvaughn/chronicle/features/sources/SourceManagerFragment.kt	(date 1601492852383)
@@ -0,0 +1,106 @@
+package io.github.mattpvaughn.chronicle.features.sources
+
+import android.os.Bundle
+import android.view.LayoutInflater
+import android.view.View
+import android.view.ViewGroup
+import android.widget.Toast
+import androidx.coordinatorlayout.widget.CoordinatorLayout
+import androidx.fragment.app.Fragment
+import androidx.lifecycle.ViewModelProvider
+import com.google.android.material.bottomsheet.BottomSheetBehavior
+import io.github.mattpvaughn.chronicle.application.MainActivity
+import io.github.mattpvaughn.chronicle.data.sources.MediaSource
+import io.github.mattpvaughn.chronicle.data.sources.SourceManager
+import io.github.mattpvaughn.chronicle.data.sources.plex.PlexLoginRepo.Companion.ARG_ERROR_MESSAGE_NO_PLEX_SOURCE_FOUND
+import io.github.mattpvaughn.chronicle.databinding.FragmentSourceManagerBinding
+import io.github.mattpvaughn.chronicle.util.Event
+import timber.log.Timber
+import javax.inject.Inject
+
+
+class SourceManagerFragment : Fragment() {
+
+    companion object {
+        @JvmStatic
+        fun newInstance() = SourceManagerFragment()
+
+        const val TAG = "SourceManagerFragment"
+    }
+
+    @Inject
+    lateinit var viewModelFactory: SourceManagerViewModel.Factory
+
+    private lateinit var viewModel: SourceManagerViewModel
+
+    private lateinit var sourceListAdapter: SourceListAdapter
+
+    @Inject
+    lateinit var sourceManager: SourceManager
+
+    override fun onCreateView(
+        inflater: LayoutInflater,
+        container: ViewGroup?,
+        savedInstanceState: Bundle?
+    ): View? {
+        (requireActivity() as MainActivity).activityComponent!!.inject(this)
+        super.onCreate(savedInstanceState)
+
+        val binding = FragmentSourceManagerBinding.inflate(inflater, container, false)
+        binding.lifecycleOwner = viewLifecycleOwner
+
+        val errorMessage: String? = arguments?.getString(ARG_ERROR_MESSAGE_NO_PLEX_SOURCE_FOUND)
+
+        viewModel = ViewModelProvider(
+            viewModelStore,
+            viewModelFactory
+        ).get(SourceManagerViewModel::class.java)
+
+        binding.viewModel = viewModel
+
+        val bottomSheetParams = binding.sourceEditor.layoutParams as CoordinatorLayout.LayoutParams
+        val bottomSheetBehavior = bottomSheetParams.behavior as BottomSheetBehavior
+        sourceListAdapter = SourceListAdapter(
+            SourceClickListener { source ->
+                Timber.i("Clicked source: $source")
+                viewModel.showEditSource(source)
+            })
+
+        binding.sourceList.adapter = sourceListAdapter
+
+        viewModel.userMessage.observe(viewLifecycleOwner) { message: Event<String> ->
+            if (!message.hasBeenHandled) {
+                Toast.makeText(context, message.getContentIfNotHandled(), Toast.LENGTH_SHORT).show()
+            }
+        }
+
+        viewModel.sources.observe(viewLifecycleOwner) { libraries ->
+            Timber.i("Updated sources")
+            sourceListAdapter.submitList(libraries ?: emptyList())
+        }
+
+        binding.addNewSource.setOnClickListener {
+            viewModel.addSource()
+        }
+
+        errorMessage?.let {
+            viewModel.showErrorMessage(it)
+        }
+
+        viewModel.source.observe(viewLifecycleOwner) { sourceWrapper ->
+            Timber.i("Opening source: $sourceWrapper")
+            bottomSheetBehavior.state = if (sourceWrapper.isEmpty) {
+                BottomSheetBehavior.STATE_HIDDEN
+            } else {
+                BottomSheetBehavior.STATE_EXPANDED
+            }
+        }
+
+        return binding.root
+    }
+
+}
+
+class SourceClickListener(val clickListener: (MediaSource) -> Unit) {
+    fun onClick(mediaSource: MediaSource) = clickListener(mediaSource)
+}
Index: app/src/main/res/drawable/option_background.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/res/drawable/option_background.xml b/app/src/main/res/drawable/option_background.xml
new file mode 100755
--- /dev/null	(date 1594308069471)
+++ b/app/src/main/res/drawable/option_background.xml	(date 1594308069471)
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="utf-8"?>
+<selector xmlns:android="http://schemas.android.com/apk/res/android">
+    <item android:drawable="@drawable/option_background_checked" android:state_checked="true" />
+    <item android:drawable="@drawable/option_background_unchecked" android:state_checked="false" />
+</selector>
Index: app/src/main/java/io/github/mattpvaughn/chronicle/features/sources/SourceListAdapter.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/io/github/mattpvaughn/chronicle/features/sources/SourceListAdapter.kt b/app/src/main/java/io/github/mattpvaughn/chronicle/features/sources/SourceListAdapter.kt
new file mode 100755
--- /dev/null	(date 1601391975389)
+++ b/app/src/main/java/io/github/mattpvaughn/chronicle/features/sources/SourceListAdapter.kt	(date 1601391975389)
@@ -0,0 +1,52 @@
+package io.github.mattpvaughn.chronicle.features.sources
+
+import android.view.LayoutInflater
+import android.view.ViewGroup
+import androidx.recyclerview.widget.DiffUtil
+import androidx.recyclerview.widget.ListAdapter
+import androidx.recyclerview.widget.RecyclerView
+import io.github.mattpvaughn.chronicle.data.sources.MediaSource
+import io.github.mattpvaughn.chronicle.databinding.ListItemSourceBinding
+
+class SourceListAdapter(val clickListener: SourceClickListener) :
+    ListAdapter<MediaSource, SourceListAdapter.SourceViewHolder>(
+        ServerDiffCallback()
+    ) {
+
+    override fun onBindViewHolder(holder: SourceViewHolder, position: Int) {
+        holder.bind(getItem(position), clickListener)
+    }
+
+    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): SourceViewHolder {
+        return SourceViewHolder.from(parent)
+    }
+
+    class SourceViewHolder private constructor(val binding: ListItemSourceBinding) :
+        RecyclerView.ViewHolder(binding.root) {
+        fun bind(source: MediaSource, clickListener: SourceClickListener) {
+            binding.source = source
+            binding.clickListener = clickListener
+            binding.executePendingBindings()
+        }
+
+        companion object {
+            fun from(parent: ViewGroup): SourceViewHolder {
+                val layoutInflater = LayoutInflater.from(parent.context)
+                val binding = ListItemSourceBinding.inflate(layoutInflater, parent, false)
+                return SourceViewHolder(binding)
+            }
+        }
+    }
+}
+
+
+class ServerDiffCallback : DiffUtil.ItemCallback<MediaSource>() {
+    override fun areItemsTheSame(oldItem: MediaSource, newItem: MediaSource): Boolean {
+        return oldItem.id == newItem.id
+    }
+
+    override fun areContentsTheSame(oldItem: MediaSource, newItem: MediaSource): Boolean {
+        return oldItem.id == newItem.id
+    }
+}
+
Index: app/src/main/java/io/github/mattpvaughn/chronicle/data/CachedFileManager.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/io/github/mattpvaughn/chronicle/data/CachedFileManager.kt b/app/src/main/java/io/github/mattpvaughn/chronicle/data/CachedFileManager.kt
new file mode 100755
--- /dev/null	(date 1601392971353)
+++ b/app/src/main/java/io/github/mattpvaughn/chronicle/data/CachedFileManager.kt	(date 1601392971353)
@@ -0,0 +1,304 @@
+package io.github.mattpvaughn.chronicle.data
+
+import android.app.DownloadManager
+import android.app.DownloadManager.*
+import android.net.Uri
+import io.github.mattpvaughn.chronicle.application.Injector
+import io.github.mattpvaughn.chronicle.data.local.IBookRepository
+import io.github.mattpvaughn.chronicle.data.local.ITrackRepository
+import io.github.mattpvaughn.chronicle.data.local.ITrackRepository.Companion.TRACK_NOT_FOUND
+import io.github.mattpvaughn.chronicle.data.local.PrefsRepo
+import io.github.mattpvaughn.chronicle.data.model.Audiobook
+import io.github.mattpvaughn.chronicle.data.model.MediaItemTrack
+import io.github.mattpvaughn.chronicle.data.model.NO_AUDIOBOOK_FOUND_ID
+import io.github.mattpvaughn.chronicle.data.sources.HttpMediaSource
+import io.github.mattpvaughn.chronicle.data.sources.SourceManager
+import kotlinx.coroutines.Dispatchers
+import kotlinx.coroutines.withContext
+import timber.log.Timber
+import java.io.File
+import java.io.FileFilter
+import java.io.IOException
+import javax.inject.Inject
+
+interface ICachedFileManager {
+    enum class CacheStatus {
+        CACHED,
+        CACHING,
+        NOT_CACHED
+    }
+
+    fun cancelCaching()
+    fun downloadTracks(tracks: List<MediaItemTrack>)
+    suspend fun uncacheAllInLibrary(): Int
+    suspend fun deleteCachedBook(tracks: List<MediaItemTrack>): Result<Unit>
+    suspend fun hasUserCachedTracks(): Boolean
+    suspend fun refreshTrackDownloadedStatus()
+    suspend fun handleDownloadedTrack(downloadId: Long): Result<Long>
+}
+
+class CachedFileManager @Inject constructor(
+    private val downloadManager: DownloadManager,
+    private val prefsRepo: PrefsRepo,
+    private val trackRepository: ITrackRepository,
+    private val bookRepository: IBookRepository,
+    private val sourceManager: SourceManager
+) : ICachedFileManager {
+
+    private val externalFileDirs = Injector.get().externalDeviceDirs()
+
+    // Keep a list of tracks which we are actively caching so they can be canceled if needed
+    private var cacheQueue = ArrayList<Long>()
+
+    override fun cancelCaching() {
+        cacheQueue.forEach { downloadManager.remove(it) }
+    }
+
+    override suspend fun hasUserCachedTracks(): Boolean {
+        return withContext(Dispatchers.IO) {
+            trackRepository.getCachedTracks().isNotEmpty()
+        }
+    }
+
+    override fun downloadTracks(tracks: List<MediaItemTrack>) {
+        cacheQueue.clear()
+        val cachedFilesDir = prefsRepo.cachedMediaDir
+        Timber.i("Caching tracks to: ${cachedFilesDir.path}")
+        tracks.sortedBy { it.index }.forEach { track ->
+            if (!track.cached) {
+                val destFile = File(cachedFilesDir, track.getCachedFileName())
+                if (destFile.exists()) {
+                    // File exists but is not marked as cached in the database- more likely than not
+                    // this means that we failed to download this previously
+                    val deleted = destFile.delete()
+                    if (!deleted) {
+                        Timber.e("Failed to delete previously cached file. Download will fail!")
+                    } else {
+                        Timber.e("Succeeding in deleting cached file")
+                    }
+                }
+                val dest = Uri.parse("file://${destFile.absolutePath}")
+                val source = sourceManager.getSourceById(track.source)
+                if (source is HttpMediaSource) {
+                    val request = source.makeDownloadRequest(track.media)
+                        .setTitle("#${track.index} ${track.album}")
+                        .setDescription("Downloading")
+                        .setDestinationUri(dest)
+                    val downId = downloadManager.enqueue(request)
+                    cacheQueue.add(downId)
+                }
+            }
+        }
+    }
+
+    override suspend fun uncacheAllInLibrary(): Int {
+        Timber.i("Removing books from library")
+        val cachedTrackNamesForLibrary = trackRepository.getCachedTracks()
+            .map { it.getCachedFileName() }
+        val allCachedTrackFiles = externalFileDirs.flatMap { dir ->
+            dir.listFiles(FileFilter {
+                MediaItemTrack.cachedFilePattern.matches(it.name)
+            })?.toList() ?: emptyList()
+        }
+        allCachedTrackFiles.forEach {
+            Timber.i("Cached for library: $cachedTrackNamesForLibrary")
+            if (cachedTrackNamesForLibrary.contains(it.name)) {
+                Timber.i("Deleting file: ${it.name}")
+                it.delete()
+            } else {
+                Timber.i("Not deleting file: ${it.name}")
+            }
+        }
+        trackRepository.uncacheAll()
+        bookRepository.uncacheAll()
+        return allCachedTrackFiles.size
+    }
+
+    /**
+     * Deletes cached tracks from the filesystem corresponding to [tracks]. Assume all tracks have
+     * the correct [MediaItemTrack.parentKey] set
+     *
+     * Return [Result.success] on successful deletion of all files or [Result.failure] if the
+     * deletion of any files fail
+     */
+    override suspend fun deleteCachedBook(tracks: List<MediaItemTrack>): Result<Unit> {
+        val cacheLoc = prefsRepo.cachedMediaDir
+        val results: List<Result<Unit>> = tracks.map { track ->
+            val cachedFile = File(cacheLoc, track.getCachedFileName())
+            if (!cachedFile.exists()) {
+                // If the cached file is already deleted, that's a success
+                trackRepository.updateCachedStatus(track.id, false)
+                return@map Result.success(Unit)
+            }
+            val deleted = cachedFile.delete()
+            if (!deleted) {
+                return@map Result.failure<Unit>(IOException("Cached file not deleted"))
+            } else {
+                Timber.i("Removed cached file $cachedFile")
+                trackRepository.updateCachedStatus(track.id, false)
+                return@map Result.success(Unit)
+            }
+        }
+        val failures = results.filter { it.isFailure }
+        return if (failures.isEmpty()) {
+            withContext(Dispatchers.IO) {
+                val bookId = tracks.firstOrNull()?.parentKey ?: NO_AUDIOBOOK_FOUND_ID
+                val book = bookRepository.getAudiobookAsync(bookId)
+                if (book != null) {
+                    bookRepository.update(book.copy(
+                        isCached = false,
+                        chapters = book.chapters.map { it.copy(downloaded = false) }
+                    ))
+                }
+            }
+            Result.success(Unit)
+        } else {
+            // Only return the first failure
+            failures.first()
+        }
+    }
+
+    /** Handle track download finished */
+    override suspend fun handleDownloadedTrack(downloadId: Long): Result<Long> {
+        val result = getTrackIdForDownload(downloadId)
+        if (result.isFailure) {
+            Timber.e(result.exceptionOrNull())
+            return result
+        }
+
+        Timber.i("Download completed for track with id: ${result.getOrNull()}")
+        val trackId: Int = result.getOrNull()?.toInt() ?: TRACK_NOT_FOUND
+        if (trackId == TRACK_NOT_FOUND) {
+            return Result.failure(Exception("Track not found!"))
+        }
+        withContext(Dispatchers.IO) {
+            trackRepository.updateCachedStatus(trackId, true)
+            val bookId: Int = trackRepository.getBookIdForTrack(trackId)
+            val book: Audiobook? = bookRepository.getAudiobookAsync(bookId)
+            val tracks = trackRepository.getTracksForAudiobookAsync(bookId)
+            // Set the book as cached only when all tracks in it have been cached
+            val isBookCached =
+                tracks.filter { it.cached }.size == tracks.size && tracks.isNotEmpty()
+            if (isBookCached && book != null) {
+                Timber.i("Should be caching book with id $bookId")
+                bookRepository.update(
+                    book.copy(
+                        isCached = isBookCached,
+                        chapters = book.chapters.map { it.copy(downloaded = isBookCached) })
+                )
+            }
+        }
+        return result
+    }
+
+    /**
+     * Find the [MediaItemTrack.id] for a track where [DownloadManager.enqueue] has already been
+     * called and the download has finished.
+     *
+     * Retrieve info from [DownloadManager] via the [downloadId] returned by [DownloadManager.enqueue]
+     */
+    private fun getTrackIdForDownload(downloadId: Long): Result<Long> {
+        val query = Query().apply { setFilterById(downloadId) }
+        val cur = downloadManager.query(query)
+        if (!cur.moveToFirst()) {
+            return Result.failure(Exception("No download found with id: $downloadId. Perhaps the download was canceled"))
+        }
+        val statusColumnIndex = cur.getColumnIndex(COLUMN_STATUS)
+        if (STATUS_SUCCESSFUL != cur.getInt(statusColumnIndex)) {
+            val errorReason = cur.getInt(cur.getColumnIndex(COLUMN_REASON))
+            val titleColumn = cur.getString(cur.getColumnIndex(COLUMN_TITLE))
+            return Result.failure(
+                Exception("Download failed for \"$titleColumn\". Error code: ($errorReason)")
+            )
+        }
+        val downloadedFilePath = cur.getString(cur.getColumnIndex(COLUMN_LOCAL_URI))
+
+        /** Assume that the filename is also the key of the track */
+        val downloadedTrack = File(downloadedFilePath.toString())
+        val trackName = downloadedTrack.name
+        if (!MediaItemTrack.cachedFilePattern.matches(trackName)) {
+            // Attempt to delete the previous failed download, then rename this download
+            val trackId = MediaItemTrack.getTrackIdFromFileName(trackName).toString()
+            val trackFileName = trackId + downloadedTrack.extension
+            val newTrackFile = File(downloadedTrack.parentFile, trackFileName)
+            downloadedTrack.renameTo(newTrackFile)
+            Timber.i("Renamed download to: ${newTrackFile.absolutePath}")
+            return if (newTrackFile.exists()) {
+                Result.success(trackId.toLong())
+            } else {
+                Result.failure(
+                    IllegalStateException("Downloaded file already exists and could not replace it")
+                )
+            }
+        }
+        return try {
+            Result.success(MediaItemTrack.getTrackIdFromFileName(trackName).toLong())
+        } catch (e: Throwable) {
+            Result.failure(Exception("Failed to get track id: ${e.message}"))
+        } finally {
+            cur.close()
+        }
+    }
+
+    /** Update [trackRepository] and [bookRepository] to reflect download files */
+    override suspend fun refreshTrackDownloadedStatus() {
+        val idToFileMap = HashMap<Int, File>()
+        val trackIdsFoundOnDisk = prefsRepo.cachedMediaDir.listFiles(FileFilter {
+            MediaItemTrack.cachedFilePattern.matches(it.name)
+        })?.map {
+            val id = MediaItemTrack.getTrackIdFromFileName(it.name)
+            idToFileMap[id] = it
+            id
+        } ?: emptyList()
+
+        val reportedCachedKeys = trackRepository.getCachedTracks().map { it.id }
+
+        val alteredTracks = mutableListOf<Int>()
+
+        // Exists in DB but not in cache- remove from DB!
+        reportedCachedKeys.filter {
+            !trackIdsFoundOnDisk.contains(it)
+        }.forEach {
+            Timber.i("Removed track: $it")
+            alteredTracks.add(it)
+            trackRepository.updateCachedStatus(it, false)
+        }
+
+        // Exists in cache but not in DB- add to DB!
+        trackIdsFoundOnDisk.filter {
+            !reportedCachedKeys.contains(it)
+        }.forEach {
+            val rowsUpdated = trackRepository.updateCachedStatus(it, true)
+            if (rowsUpdated == 0) {
+                // TODO: this will be relevant when multiple sources is implemented, but for now
+                //       we just have to trust, as they could be from other libraries
+//                // File has been orphaned- no longer exists in DB, remove it from file system!
+//                idToFileMap[it]?.delete()
+            } else {
+                alteredTracks.add(it)
+            }
+        }
+
+        // Update cached status for the books containing any added/removed tracks
+        alteredTracks.map {
+            trackRepository.getBookIdForTrack(it)
+        }.distinct().forEach { bookId: Int ->
+            Timber.i("Book: $bookId")
+            if (bookId == NO_AUDIOBOOK_FOUND_ID) {
+                return@forEach
+            }
+            val bookTrackCacheCount =
+                trackRepository.getCachedTrackCountForBookAsync(bookId)
+            val bookTrackCount = trackRepository.getTrackCountForBookAsync(bookId)
+            val isBookCached = bookTrackCacheCount == bookTrackCount && bookTrackCount > 0
+            val book = bookRepository.getAudiobookAsync(bookId)
+            if (book != null) {
+                bookRepository.update(book.copy(
+                    isCached = isBookCached,
+                    chapters = book.chapters.map { it.copy(downloaded = isBookCached) }
+                ))
+            }
+        }
+    }
+}
+
Index: app/src/main/res/layout/onboarding_add_source.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/res/layout/onboarding_add_source.xml b/app/src/main/res/layout/onboarding_add_source.xml
new file mode 100755
--- /dev/null	(date 1601391975401)
+++ b/app/src/main/res/layout/onboarding_add_source.xml	(date 1601391975401)
@@ -0,0 +1,121 @@
+<?xml version="1.0" encoding="utf-8"?>
+<layout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto">
+
+    <data>
+
+        <variable
+            name="viewModel"
+            type="io.github.mattpvaughn.chronicle.features.login.AddSourceViewModel" />
+
+        <import type="io.github.mattpvaughn.chronicle.application.ConstantsKt" />
+
+        <import type="android.view.View" />
+    </data>
+
+    <androidx.constraintlayout.widget.ConstraintLayout
+        android:id="@+id/container"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:background="@color/colorPrimaryDark">
+
+        <com.google.android.material.button.MaterialButton
+            android:id="@+id/oauth_login"
+            style="@style/Widget.MaterialComponents.Button"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:drawableStart="@drawable/ic_lock_white_24dp"
+            android:onClick="@{ () -> viewModel.loginWithPlexOAuth()}"
+            android:paddingLeft="@dimen/plex_button_padding_horizontal"
+            android:paddingTop="@dimen/plex_button_padding_vertical"
+            android:paddingRight="@dimen/plex_button_padding_horizontal"
+            android:paddingBottom="@dimen/plex_button_padding_vertical"
+            android:text="@string/login_with_plex"
+            android:textColor="@color/textPrimary"
+            app:backgroundTint="@color/accent_plex"
+            app:layout_constraintBottom_toTopOf="@id/add_jellyfin"
+            app:layout_constraintLeft_toLeftOf="parent"
+            android:layout_marginBottom="@dimen/spacing_normal"
+            app:layout_constraintRight_toRightOf="parent"
+            app:layout_constraintTop_toTopOf="parent"
+            app:layout_constraintVertical_chainStyle="packed" />
+
+        <com.google.android.material.button.MaterialButton
+            android:id="@+id/add_jellyfin"
+            style="@style/Widget.MaterialComponents.Button"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:paddingLeft="@dimen/plex_button_padding_horizontal"
+            android:layout_marginBottom="@dimen/spacing_normal"
+            android:backgroundTint="@color/jellyfin"
+            android:paddingTop="@dimen/plex_button_padding_vertical"
+            android:paddingRight="@dimen/plex_button_padding_horizontal"
+            android:paddingBottom="@dimen/plex_button_padding_vertical"
+            android:text="@string/login_with_jellyfin"
+            android:textColor="@color/textPrimary"
+            app:layout_constraintBottom_toTopOf="@id/add_directory"
+            app:layout_constraintLeft_toLeftOf="parent"
+            app:layout_constraintRight_toRightOf="parent"
+            app:layout_constraintTop_toBottomOf="@id/oauth_login"
+            app:layout_constraintVertical_chainStyle="packed" />
+
+        <com.google.android.material.button.MaterialButton
+            android:id="@+id/add_directory"
+            style="@style/Widget.MaterialComponents.Button"
+            android:layout_marginBottom="@dimen/spacing_normal"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:paddingLeft="@dimen/plex_button_padding_horizontal"
+            android:paddingTop="@dimen/plex_button_padding_vertical"
+            android:paddingRight="@dimen/plex_button_padding_horizontal"
+            android:paddingBottom="@dimen/plex_button_padding_vertical"
+            android:text="@string/folder_source"
+            android:textColor="@color/textPrimary"
+            app:backgroundTint="@android:color/holo_blue_dark"
+            app:layout_constraintBottom_toTopOf="@id/demo_library"
+            app:layout_constraintLeft_toLeftOf="parent"
+            app:layout_constraintRight_toRightOf="parent"
+            app:layout_constraintTop_toBottomOf="@id/add_jellyfin"
+            app:layout_constraintVertical_chainStyle="packed" />
+
+        <TextView
+            android:id="@+id/demo_library"
+            style="@style/TextAppearance.Body1"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:autoLink="all"
+            android:linksClickable="false"
+            android:onClick="@{() -> viewModel.addDemoLibrary()}"
+            android:selectAllOnFocus="false"
+            android:text="@string/source_demo_library"
+            app:layout_constraintBottom_toBottomOf="parent"
+            app:layout_constraintLeft_toLeftOf="parent"
+            app:layout_constraintRight_toRightOf="parent"
+            app:layout_constraintTop_toBottomOf="@id/add_directory" />
+
+        <ProgressBar
+            android:id="@+id/loading"
+            android:layout_width="@dimen/fab_size_imageview"
+            android:layout_height="@dimen/fab_size_imageview"
+            android:layout_gravity="center"
+            android:layout_margin="@dimen/margin_normal"
+            android:visibility="@{viewModel.isLoading().booleanValue() ? View.VISIBLE : View.GONE}"
+            app:layout_constraintLeft_toLeftOf="parent"
+            app:layout_constraintRight_toRightOf="parent"
+            app:layout_constraintTop_toBottomOf="@id/oauth_login" />
+
+        <com.google.android.material.checkbox.MaterialCheckBox
+            android:id="@+id/enable_auto"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_marginTop="@dimen/margin_large"
+            android:checked="@{viewModel.allowAuto}"
+            android:text="@string/allow_auto"
+            android:textColor="@color/textPrimary"
+            android:visibility="@{ConstantsKt.FEATURE_FLAG_IS_AUTO_ENABLED ? View.VISIBLE : View.GONE}"
+            app:buttonTint="@color/textPrimary"
+            app:layout_constraintLeft_toLeftOf="parent"
+            app:layout_constraintRight_toRightOf="parent"
+            app:layout_constraintTop_toBottomOf="@id/demo_library" />
+    </androidx.constraintlayout.widget.ConstraintLayout>
+</layout>
Index: app/src/main/res/drawable/ic_add_no_outline.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/res/drawable/ic_add_no_outline.xml b/app/src/main/res/drawable/ic_add_no_outline.xml
new file mode 100755
--- /dev/null	(date 1601407213884)
+++ b/app/src/main/res/drawable/ic_add_no_outline.xml	(date 1601407213884)
@@ -0,0 +1,5 @@
+<vector android:height="24dp" android:tint="#FFFFFF"
+    android:viewportHeight="24" android:viewportWidth="24"
+    android:width="24dp" xmlns:android="http://schemas.android.com/apk/res/android">
+    <path android:fillColor="@android:color/white" android:pathData="M19,13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/>
+</vector>
Index: app/src/main/java/io/github/mattpvaughn/chronicle/data/ConnectionState.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/io/github/mattpvaughn/chronicle/data/ConnectionState.kt b/app/src/main/java/io/github/mattpvaughn/chronicle/data/ConnectionState.kt
new file mode 100755
--- /dev/null	(date 1601391975341)
+++ b/app/src/main/java/io/github/mattpvaughn/chronicle/data/ConnectionState.kt	(date 1601391975341)
@@ -0,0 +1,9 @@
+package io.github.mattpvaughn.chronicle.data
+
+enum class ConnectionState {
+    CONNECTING,
+    NOT_CONNECTED,
+    CONNECTED,
+    CONNECTION_FAILED
+}
+
Index: app/src/main/java/io/github/mattpvaughn/chronicle/data/Constants.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/io/github/mattpvaughn/chronicle/data/Constants.kt b/app/src/main/java/io/github/mattpvaughn/chronicle/data/Constants.kt
new file mode 100755
--- /dev/null	(date 1601391975341)
+++ b/app/src/main/java/io/github/mattpvaughn/chronicle/data/Constants.kt	(date 1601391975341)
@@ -0,0 +1,62 @@
+package io.github.mattpvaughn.chronicle.data
+
+const val MEDIA_TYPE_ALBUM = 9
+const val MEDIA_TYPE_TRACK = 10
+const val APP_NAME = "Chronicle"
+
+/** ---- For android auto ---- */
+
+/** Declares that ContentStyle is supported */
+const val CONTENT_STYLE_SUPPORTED = "android.media.browse.CONTENT_STYLE_SUPPORTED"
+
+/**
+ * Bundle extra indicating the presentation hint for playable media items.
+ */
+const val CONTENT_STYLE_PLAYABLE_HINT = "android.media.browse.CONTENT_STYLE_PLAYABLE_HINT"
+
+/**
+ * Bundle extra indicating the presentation hint for browsable media items.
+ */
+val CONTENT_STYLE_BROWSABLE_HINT = "android.media.browse.CONTENT_STYLE_BROWSABLE_HINT"
+
+/**
+ * Specifies the corresponding items should be presented as lists.
+ */
+const val CONTENT_STYLE_LIST_ITEM_HINT_VALUE = 1
+
+/**
+ * Specifies that the corresponding items should be presented as grids.
+ */
+const val CONTENT_STYLE_GRID_ITEM_HINT_VALUE = 2
+
+/**
+ * Bundle extra indicating that a media item is available offline.
+ * Same as MediaDescriptionCompat.EXTRA_DOWNLOAD_STATUS.
+ */
+const val EXTRA_IS_DOWNLOADED = "android.media.extra.DOWNLOAD_STATUS"
+
+/**
+ * Bundle extra indicating the played state of long-form content (such as podcast
+ * episodes or audiobooks).
+ */
+const val EXTRA_PLAY_COMPLETION_STATE = "android.media.extra.PLAYBACK_STATUS"
+
+/**
+ * Value for EXTRA_PLAY_COMPLETION_STATE that indicates the media item has
+ * not been played at all.
+ */
+const val STATUS_NOT_PLAYED = 0
+
+/**
+ * Value for EXTRA_PLAY_COMPLETION_STATE that indicates the media item has
+ * been partially played (i.e. the current position is somewhere in the middle).
+ */
+const val STATUS_PARTIALLY_PLAYED = 1
+
+/**
+ * Value for EXTRA_PLAY_COMPLETION_STATE that indicates the media item has
+ * been completed.
+ */
+const val STATUS_FULLY_PLAYED = 2
+
+
Index: app/src/main/java/io/github/mattpvaughn/chronicle/data/local/DataManager.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/io/github/mattpvaughn/chronicle/data/local/DataManager.kt b/app/src/main/java/io/github/mattpvaughn/chronicle/data/local/DataManager.kt
new file mode 100755
--- /dev/null	(date 1601391975345)
+++ b/app/src/main/java/io/github/mattpvaughn/chronicle/data/local/DataManager.kt	(date 1601391975345)
@@ -0,0 +1,44 @@
+package io.github.mattpvaughn.chronicle.data.local
+
+import io.github.mattpvaughn.chronicle.data.model.getProgress
+import io.github.mattpvaughn.chronicle.data.sources.plex.model.getDuration
+import timber.log.Timber
+
+class DataManager {
+
+    companion object {
+        suspend fun refreshData(
+            bookRepository: IBookRepository,
+            trackRepository: ITrackRepository
+        ): String? {
+            val result = try {
+                val bookResults = bookRepository.refreshData()
+                val trackResults = trackRepository.refreshData()
+                val allResults = bookResults.union(trackResults)
+                val failures =
+                    allResults.filter { it.isFailure }.map { it.exceptionOrNull()?.message ?: "" }
+                return if (failures.isNotEmpty()) {
+                    "Failed to load (${failures.size}/${allResults.size}): $failures"
+                } else {
+                    null
+                }
+            } catch (e: Throwable) {
+                e.message
+            }
+
+            val audiobooks = bookRepository.getAllBooksAsync()
+            val tracks = trackRepository.getAllTracksAsync()
+            audiobooks.forEach { book ->
+                val tracksInAudiobook = tracks.filter { it.parentKey == book.id }
+                Timber.i("Book progress: ${tracksInAudiobook.getProgress()}")
+                bookRepository.updateTrackData(
+                    bookId = book.id,
+                    bookProgress = tracksInAudiobook.getProgress(),
+                    bookDuration = tracksInAudiobook.getDuration(),
+                    trackCount = tracksInAudiobook.size
+                )
+            }
+            return result
+        }
+    }
+}
\ No newline at end of file
Index: app/src/main/res/drawable/jellyfin_gradient.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/res/drawable/jellyfin_gradient.xml b/app/src/main/res/drawable/jellyfin_gradient.xml
new file mode 100755
--- /dev/null	(date 1601391975397)
+++ b/app/src/main/res/drawable/jellyfin_gradient.xml	(date 1601391975397)
@@ -0,0 +1,11 @@
+<?xml version="1.0" encoding="utf-8"?>
+<shape xmlns:android="http://schemas.android.com/apk/res/android"
+    android:shape="rectangle">
+
+    <!-- Gradient top is transparent, bottom is black -->
+    <gradient
+        android:angle="270"
+        android:endColor="#00A4DC"
+        android:startColor="#AA5CC3" />
+
+</shape>
\ No newline at end of file
Index: app/src/main/java/io/github/mattpvaughn/chronicle/features/login/AddSourceFragment.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/io/github/mattpvaughn/chronicle/features/login/AddSourceFragment.kt b/app/src/main/java/io/github/mattpvaughn/chronicle/features/login/AddSourceFragment.kt
new file mode 100755
--- /dev/null	(date 1601398793233)
+++ b/app/src/main/java/io/github/mattpvaughn/chronicle/features/login/AddSourceFragment.kt	(date 1601398793233)
@@ -0,0 +1,132 @@
+package io.github.mattpvaughn.chronicle.features.login
+
+import android.content.Context
+import android.graphics.Bitmap
+import android.graphics.Color
+import android.graphics.drawable.BitmapDrawable
+import android.os.Build
+import android.os.Bundle
+import android.view.LayoutInflater
+import android.view.View
+import android.view.ViewGroup
+import androidx.browser.customtabs.CustomTabsIntent
+import androidx.fragment.app.Fragment
+import androidx.lifecycle.Observer
+import androidx.lifecycle.ViewModelProvider
+import io.github.mattpvaughn.chronicle.R
+import io.github.mattpvaughn.chronicle.application.MainActivity
+import io.github.mattpvaughn.chronicle.data.local.PrefsRepo
+import io.github.mattpvaughn.chronicle.data.sources.MediaSource
+import io.github.mattpvaughn.chronicle.data.sources.MediaSourceFactory
+import io.github.mattpvaughn.chronicle.data.sources.SourceManager
+import io.github.mattpvaughn.chronicle.data.sources.plex.PlexLibrarySource
+import io.github.mattpvaughn.chronicle.data.sources.plex.model.OAuthResponse
+import io.github.mattpvaughn.chronicle.databinding.OnboardingAddSourceBinding
+import io.github.mattpvaughn.chronicle.injection.components.AppComponent.Companion.USER_AGENT
+import timber.log.Timber
+import javax.inject.Inject
+import javax.inject.Named
+
+/** Fragment responsible for starting the process of adding a new [MediaSource] */
+class AddSourceFragment : Fragment() {
+
+    companion object {
+        @JvmStatic
+        fun newInstance() = AddSourceFragment()
+        const val TAG: String = "Login tag"
+    }
+
+    @Inject
+    lateinit var prefsRepo: PrefsRepo
+
+    @Inject
+    lateinit var viewModelFactory: AddSourceViewModel.Factory
+
+    @Inject
+    lateinit var sourceManager: SourceManager
+
+    @Inject
+    lateinit var mediaSourceFactory: MediaSourceFactory
+
+
+    @Inject
+    @Named(USER_AGENT)
+    lateinit var userAgent: String
+
+
+    private lateinit var addSourceViewModel: AddSourceViewModel
+
+    override fun onAttach(context: Context) {
+        (requireActivity() as MainActivity).activityComponent!!.inject(this)
+        super.onAttach(context)
+    }
+
+    override fun onCreateView(
+        inflater: LayoutInflater,
+        container: ViewGroup?,
+        savedInstanceState: Bundle?
+    ): View? {
+
+        val potentialPlexSource = mediaSourceFactory.create(
+            sourceManager.generateUniqueId(),
+            PlexLibrarySource.TAG
+        ) as PlexLibrarySource
+        viewModelFactory.potentialPlexSource = potentialPlexSource
+
+        addSourceViewModel = ViewModelProvider(
+            this,
+            viewModelFactory
+        ).get(AddSourceViewModel::class.java)
+
+        val binding = OnboardingAddSourceBinding.inflate(inflater, container, false)
+        binding.lifecycleOwner = viewLifecycleOwner
+        binding.viewModel = addSourceViewModel
+
+        addSourceViewModel.authEvent.observe(viewLifecycleOwner, Observer { authRequestEvent ->
+            val oAuthPin = authRequestEvent.getContentIfNotHandled()
+            if (oAuthPin != null) {
+                showPlexLoginWindow(oAuthPin)
+            }
+        })
+
+        return binding.root
+    }
+
+    private fun showPlexLoginWindow(oAuthPin: OAuthResponse) {
+        val backButton =
+            resources.getDrawable(R.drawable.ic_arrow_back_white, requireActivity().theme)
+                .apply { setTint(Color.BLACK) }
+        val backButtonBitmap: Bitmap? =
+            if (backButton is BitmapDrawable) backButton.bitmap else null
+
+        @Suppress("DEPRECATION")
+        val customTabsIntentBuilder =
+            CustomTabsIntent.Builder()
+                .setToolbarColor(
+                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
+                        resources.getColor(R.color.colorPrimary, requireActivity().theme)
+                    } else {
+                        resources.getColor(R.color.colorPrimary)
+                    }
+                )
+                .setShowTitle(true)
+
+        if (backButtonBitmap != null) {
+            customTabsIntentBuilder.setCloseButtonIcon(backButtonBitmap)
+        }
+
+        val customTabsIntent = customTabsIntentBuilder.build()
+
+        // make login url
+        val url = addSourceViewModel.makePlexOAuthLoginUrl(oAuthPin.clientIdentifier, oAuthPin.code)
+
+        addSourceViewModel.setLaunched(true)
+        customTabsIntent.launchUrl(requireContext(), url)
+    }
+
+    override fun onResume() {
+        Timber.i("RESUMING LoginFragment")
+        addSourceViewModel.checkForAccess()
+        super.onResume()
+    }
+}
\ No newline at end of file
Index: app/src/main/java/io/github/mattpvaughn/chronicle/data/sources/RemoteSyncScrobbleWorker.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/io/github/mattpvaughn/chronicle/data/sources/RemoteSyncScrobbleWorker.kt b/app/src/main/java/io/github/mattpvaughn/chronicle/data/sources/RemoteSyncScrobbleWorker.kt
new file mode 100755
--- /dev/null	(date 1601392971341)
+++ b/app/src/main/java/io/github/mattpvaughn/chronicle/data/sources/RemoteSyncScrobbleWorker.kt	(date 1601392971341)
@@ -0,0 +1,161 @@
+package io.github.mattpvaughn.chronicle.data.sources
+
+import android.content.Context
+import androidx.work.*
+import io.github.mattpvaughn.chronicle.application.Injector
+import io.github.mattpvaughn.chronicle.data.local.ITrackRepository.Companion.TRACK_NOT_FOUND
+import io.github.mattpvaughn.chronicle.data.model.MediaItemTrack
+import io.github.mattpvaughn.chronicle.data.model.NO_AUDIOBOOK_FOUND_ID
+import io.github.mattpvaughn.chronicle.data.sources.plex.model.getDuration
+import io.github.mattpvaughn.chronicle.features.player.MediaPlayerService.Companion.PLEX_STATE_PAUSED
+import io.github.mattpvaughn.chronicle.features.player.MediaPlayerService.Companion.PLEX_STATE_STOPPED
+import io.github.mattpvaughn.chronicle.features.player.ProgressUpdater.Companion.BOOK_FINISHED_END_OFFSET_MILLIS
+import kotlinx.coroutines.CoroutineScope
+import kotlinx.coroutines.Dispatchers
+import kotlinx.coroutines.Job
+import kotlinx.coroutines.launch
+import timber.log.Timber
+
+
+class RemoteSyncScrobbleWorker(
+    context: Context,
+    workerParameters: WorkerParameters
+) : Worker(context, workerParameters) {
+
+    val trackRepository = Injector.get().trackRepo()
+    val bookRepository = Injector.get().bookRepo()
+
+    private var workerJob = Job()
+    private val coroutineScope = CoroutineScope(workerJob + Dispatchers.IO)
+
+    override fun doWork(): Result {
+        val sourceId = inputData.requireLong(SOURCE_ID_ARG)
+        val trackId = inputData.requireInt(TRACK_ID_ARG)
+        val playbackState = inputData.requireString(TRACK_STATE_ARG)
+        val trackProgress = inputData.requireLong(TRACK_POSITION_ARG)
+        val playbackTimeStamp = inputData.requireLong(PLAYBACK_TIME_STAMP_ARG)
+        val bookProgress = inputData.requireLong(BOOK_PROGRESS_ARG)
+
+        val source = Injector.get().sourceManager().getSourceById(sourceId)
+        check(source is HttpMediaSource)
+
+        // Ensure user has server authorization scrobble data
+        if (!source.isAuthorized()) {
+            return Result.failure()
+        }
+
+        try {
+            coroutineScope.launch(Injector.get().unhandledExceptionHandler()) {
+
+                val track = trackRepository.getTrackAsync(trackId)
+                val bookId = track?.parentKey ?: NO_AUDIOBOOK_FOUND_ID
+                val book = bookRepository.getAudiobookAsync(bookId)
+                val tracks = trackRepository.getTracksForAudiobookAsync(bookId)
+
+                check(bookId != NO_AUDIOBOOK_FOUND_ID)
+                check(trackId != TRACK_NOT_FOUND && track != null)
+
+                try {
+                    source.updateProgress(
+                        trackId = trackId.toString(),
+                        trackProgress = trackProgress.toString(),
+                        playbackTime = playbackTimeStamp,
+                        playQueueItemId = track.playQueueItemID,
+                        key = "${MediaItemTrack.PARENT_KEY_PREFIX}$trackId",
+                        // IMPORTANT: Plex normally marks as watched at 90% progress, but it
+                        // calculates progress with respect to duration provided if a duration is
+                        // provided, so passing duration = actualDuration * 2 causes Plex to never
+                        // automatically mark as watched
+                        duration = track.duration * 2,
+                        playState = playbackState,
+                        hasMde = 1
+                    )
+                    Timber.i("Synced progress for ${book?.title}")
+                } catch (t: Throwable) {
+                    Timber.e("Failed to sync progress: ${t.message}")
+                }
+
+                // Consider track finished when it is within 1 second of it's end
+                val isTrackFinished = trackProgress > track.duration - 1
+                if (isTrackFinished) {
+                    try {
+                        source.watched(trackId)
+                        Timber.i("Updated watch status for: ${track.title}")
+                    } catch (t: Throwable) {
+                        Timber.e("Failed to update track watched status: ${t.message}")
+                    }
+                }
+
+                // Consider the book finished when playback pauses or stops the book with less than
+                // [BOOK_FINISHED_WINDOW] milliseconds remaining
+                val isBookAlmostEnded =
+                    tracks.getDuration() - bookProgress < BOOK_FINISHED_END_OFFSET_MILLIS
+                val hasUserEndedPlayback =
+                    playbackState == PLEX_STATE_STOPPED || playbackState == PLEX_STATE_PAUSED
+                val isBookFinished = isBookAlmostEnded && hasUserEndedPlayback
+
+                if (isBookFinished) {
+                    try {
+                        source.watched(bookId)
+                        Timber.i("Updated watch status for: ${book?.title}")
+                    } catch (t: Throwable) {
+                        Timber.e("Failed to update book watched status: ${t.message}")
+                    }
+                }
+            }
+        } catch (e: Throwable) {
+            Timber.e("Error occurred while syncing watched status! $e")
+            return Result.failure()
+        }
+
+        return Result.success()
+    }
+
+    override fun onStopped() {
+        workerJob.cancel()
+        super.onStopped()
+    }
+
+    companion object {
+        const val SOURCE_ID_ARG = "source id"
+        const val TRACK_ID_ARG = "Track ID"
+        const val TRACK_STATE_ARG = "State"
+        const val TRACK_POSITION_ARG = "Track position"
+        const val PLAYBACK_TIME_STAMP_ARG = "Original play time"
+        const val BOOK_PROGRESS_ARG = "Book progress"
+
+        fun makeWorkerData(
+            sourceId: Long,
+            trackId: Int,
+            playbackState: String,
+            trackProgress: Long,
+            bookProgress: Long,
+            playbackTimeStamp: Long = System.currentTimeMillis()
+        ): Data {
+            require(trackId != TRACK_NOT_FOUND)
+            return workDataOf(
+                SOURCE_ID_ARG to sourceId,
+                TRACK_ID_ARG to trackId,
+                TRACK_POSITION_ARG to trackProgress,
+                TRACK_STATE_ARG to playbackState,
+                PLAYBACK_TIME_STAMP_ARG to playbackTimeStamp,
+                BOOK_PROGRESS_ARG to bookProgress
+            )
+        }
+    }
+
+    private fun Data.requireInt(key: String): Int {
+        require(hasKeyWithValueOfType<Int>(key))
+        return getInt(key, -1)
+    }
+
+    private fun Data.requireLong(key: String): Long {
+        require(hasKeyWithValueOfType<Long>(key))
+        return getLong(key, -1L)
+    }
+
+    private fun Data.requireString(key: String): String {
+        require(hasKeyWithValueOfType<String>(key))
+        return getString(key) ?: ""
+    }
+}
\ No newline at end of file
Index: app/schemas/io.github.mattpvaughn.chronicle.data.local.BookDatabase/8.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/schemas/io.github.mattpvaughn.chronicle.data.local.BookDatabase/8.json b/app/schemas/io.github.mattpvaughn.chronicle.data.local.BookDatabase/8.json
new file mode 100755
--- /dev/null	(date 1619393225281)
+++ b/app/schemas/io.github.mattpvaughn.chronicle.data.local.BookDatabase/8.json	(date 1619393225281)
@@ -0,0 +1,154 @@
+{
+  "formatVersion": 1,
+  "database": {
+    "version": 8,
+    "identityHash": "5e38d4a0bc56984e59491d20776bc584",
+    "entities": [
+      {
+        "tableName": "Audiobook",
+        "createSql": "CREATE TABLE IF NOT EXISTS `${TABLE_NAME}` (`id` INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, `serverId` INTEGER NOT NULL, `source` INTEGER NOT NULL, `title` TEXT NOT NULL, `titleSort` TEXT NOT NULL, `author` TEXT NOT NULL, `thumb` TEXT NOT NULL, `parentId` INTEGER NOT NULL, `genre` TEXT NOT NULL, `summary` TEXT NOT NULL, `addedAt` INTEGER NOT NULL, `updatedAt` INTEGER NOT NULL, `lastViewedAt` INTEGER NOT NULL, `duration` INTEGER NOT NULL, `isCached` INTEGER NOT NULL, `progress` INTEGER NOT NULL, `favorited` INTEGER NOT NULL, `viewedLeafCount` INTEGER NOT NULL, `leafCount` INTEGER NOT NULL, `viewCount` INTEGER NOT NULL, `chapters` TEXT NOT NULL)",
+        "fields": [
+          {
+            "fieldPath": "id",
+            "columnName": "id",
+            "affinity": "INTEGER",
+            "notNull": true
+          },
+          {
+            "fieldPath": "serverId",
+            "columnName": "serverId",
+            "affinity": "INTEGER",
+            "notNull": true
+          },
+          {
+            "fieldPath": "source",
+            "columnName": "source",
+            "affinity": "INTEGER",
+            "notNull": true
+          },
+          {
+            "fieldPath": "title",
+            "columnName": "title",
+            "affinity": "TEXT",
+            "notNull": true
+          },
+          {
+            "fieldPath": "titleSort",
+            "columnName": "titleSort",
+            "affinity": "TEXT",
+            "notNull": true
+          },
+          {
+            "fieldPath": "author",
+            "columnName": "author",
+            "affinity": "TEXT",
+            "notNull": true
+          },
+          {
+            "fieldPath": "thumb",
+            "columnName": "thumb",
+            "affinity": "TEXT",
+            "notNull": true
+          },
+          {
+            "fieldPath": "parentId",
+            "columnName": "parentId",
+            "affinity": "INTEGER",
+            "notNull": true
+          },
+          {
+            "fieldPath": "genre",
+            "columnName": "genre",
+            "affinity": "TEXT",
+            "notNull": true
+          },
+          {
+            "fieldPath": "summary",
+            "columnName": "summary",
+            "affinity": "TEXT",
+            "notNull": true
+          },
+          {
+            "fieldPath": "addedAt",
+            "columnName": "addedAt",
+            "affinity": "INTEGER",
+            "notNull": true
+          },
+          {
+            "fieldPath": "updatedAt",
+            "columnName": "updatedAt",
+            "affinity": "INTEGER",
+            "notNull": true
+          },
+          {
+            "fieldPath": "lastViewedAt",
+            "columnName": "lastViewedAt",
+            "affinity": "INTEGER",
+            "notNull": true
+          },
+          {
+            "fieldPath": "duration",
+            "columnName": "duration",
+            "affinity": "INTEGER",
+            "notNull": true
+          },
+          {
+            "fieldPath": "isCached",
+            "columnName": "isCached",
+            "affinity": "INTEGER",
+            "notNull": true
+          },
+          {
+            "fieldPath": "progress",
+            "columnName": "progress",
+            "affinity": "INTEGER",
+            "notNull": true
+          },
+          {
+            "fieldPath": "favorited",
+            "columnName": "favorited",
+            "affinity": "INTEGER",
+            "notNull": true
+          },
+          {
+            "fieldPath": "viewedLeafCount",
+            "columnName": "viewedLeafCount",
+            "affinity": "INTEGER",
+            "notNull": true
+          },
+          {
+            "fieldPath": "leafCount",
+            "columnName": "leafCount",
+            "affinity": "INTEGER",
+            "notNull": true
+          },
+          {
+            "fieldPath": "viewCount",
+            "columnName": "viewCount",
+            "affinity": "INTEGER",
+            "notNull": true
+          },
+          {
+            "fieldPath": "chapters",
+            "columnName": "chapters",
+            "affinity": "TEXT",
+            "notNull": true
+          }
+        ],
+        "primaryKey": {
+          "columnNames": [
+            "id"
+          ],
+          "autoGenerate": true
+        },
+        "indices": [],
+        "foreignKeys": []
+      }
+    ],
+    "views": [],
+    "setupQueries": [
+      "CREATE TABLE IF NOT EXISTS room_master_table (id INTEGER PRIMARY KEY,identity_hash TEXT)",
+      "INSERT OR REPLACE INTO room_master_table (id,identity_hash) VALUES(42, '5e38d4a0bc56984e59491d20776bc584')"
+    ]
+  }
+}
\ No newline at end of file
Index: app/src/main/res/layout/view_filter.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/res/layout/view_filter.xml b/app/src/main/res/layout/view_filter.xml
new file mode 100755
--- /dev/null	(date 1601485377985)
+++ b/app/src/main/res/layout/view_filter.xml	(date 1601485377985)
@@ -0,0 +1,228 @@
+<?xml version="1.0" encoding="utf-8"?>
+<layout>
+
+    <data>
+
+        <variable
+            name="viewModel"
+            type="io.github.mattpvaughn.chronicle.features.library.LibraryViewModel" />
+
+    </data>
+
+    <androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
+        xmlns:app="http://schemas.android.com/apk/res-auto"
+        xmlns:tools="http://schemas.android.com/tools"
+        android:id="@+id/filter_view"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:background="@color/colorPrimaryDark"
+        android:clickable="true"
+        android:padding="@dimen/screen_horizontal_padding"
+        app:behavior_fitToContents="true"
+        app:behavior_hideable="true"
+        app:behavior_skipCollapsed="true"
+        app:layout_behavior="com.google.android.material.bottomsheet.BottomSheetBehavior"
+        tools:ignore="KeyboardInaccessibleWidget">
+
+        <androidx.appcompat.widget.AppCompatTextView
+            android:id="@+id/filter_title"
+            style="@style/TextAppearance.SectionHeader"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:text="@string/filter"
+            app:layout_constraintLeft_toLeftOf="parent"
+            app:layout_constraintTop_toTopOf="parent" />
+
+        <androidx.appcompat.widget.AppCompatTextView
+            android:id="@+id/done_filtering"
+            style="@style/TextAppearance.Body2"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:background="?attr/selectableItemBackground"
+            android:onClick="@{() -> viewModel.setFilterMenuVisible(false)}"
+            android:text="@string/done_filtering"
+            app:layout_constraintRight_toRightOf="parent"
+            app:layout_constraintTop_toTopOf="parent" />
+
+        <LinearLayout
+            android:id="@+id/sort_by_container"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:background="?attr/selectableItemBackground"
+            android:clickable="true"
+            android:contentDescription="@{viewModel.isSortDescending() ? @string/toggle_library_sort_ascending : @string/toggle_library_sort_descending}"
+            android:focusable="true"
+            android:onClick="@{() -> viewModel.toggleSortDirection()}"
+            android:orientation="horizontal"
+            app:layout_constraintLeft_toLeftOf="parent"
+            app:layout_constraintTop_toBottomOf="@id/filter_title">
+
+            <androidx.appcompat.widget.AppCompatTextView
+                android:id="@+id/sort_by"
+                style="@style/TextAppearance.Body1"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_gravity="center_vertical"
+                android:paddingTop="@dimen/margin_normal"
+                android:paddingBottom="@dimen/margin_normal"
+                android:text="@string/sort_by" />
+
+            <androidx.appcompat.widget.AppCompatImageView
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_gravity="center_vertical"
+                android:layout_margin="@dimen/spacing_normal"
+                android:rotationX="@{viewModel.isSortDescending() ? 0 : 180}"
+                android:src="@drawable/ic_arrow_trending_down_white"
+                android:tint="@color/icon" />
+
+        </LinearLayout>
+
+        <io.github.mattpvaughn.chronicle.views.FlowableRadioGroup
+            android:id="@+id/sort_by_options"
+            android:layout_width="0dp"
+            android:layout_height="wrap_content"
+            app:itemSpacing="@dimen/margin_small"
+            app:layout_constraintLeft_toLeftOf="parent"
+            app:layout_constraintRight_toRightOf="parent"
+            app:layout_constraintTop_toBottomOf="@id/sort_by_container"
+            app:lineSpacing="@dimen/margin_small">
+
+            <com.google.android.material.radiobutton.MaterialRadioButton
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:tag="@string/key_sort_by_title"
+                android:text="@string/sort_by_title" />
+
+            <com.google.android.material.radiobutton.MaterialRadioButton
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:tag="@string/key_sort_by_author"
+                android:text="@string/sort_by_author" />
+
+            <com.google.android.material.radiobutton.MaterialRadioButton
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:tag="@string/key_sort_by_duration"
+                android:text="@string/sort_by_duration" />
+
+            <com.google.android.material.radiobutton.MaterialRadioButton
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:tag="@string/key_sort_by_date_added"
+                android:text="@string/sort_by_date_added" />
+
+            <com.google.android.material.radiobutton.MaterialRadioButton
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:tag="@string/key_sort_by_date_played"
+                android:text="@string/sort_by_date_played" />
+
+            <!--                    <com.google.android.material.radiobutton.MaterialRadioButton-->
+            <!--                        android:layout_width="wrap_content"-->
+            <!--                        android:layout_height="wrap_content"-->
+            <!--                        android:tag="@string/key_sort_by_rating"-->
+            <!--                        android:text="@string/sort_by_rating" />-->
+
+            <!--                    <com.google.android.material.radiobutton.MaterialRadioButton-->
+            <!--                        android:layout_width="wrap_content"-->
+            <!--                        android:layout_height="wrap_content"-->
+            <!--                        android:tag="@string/key_sort_by_plays"-->
+            <!--                        android:text="@string/sort_by_plays" />-->
+
+        </io.github.mattpvaughn.chronicle.views.FlowableRadioGroup>
+
+        <androidx.appcompat.widget.AppCompatTextView
+            android:id="@+id/view_style_title"
+            style="@style/TextAppearance.Body1"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:layout_gravity="center_vertical"
+            android:paddingTop="@dimen/margin_normal"
+            android:paddingBottom="@dimen/margin_normal"
+            android:text="@string/view_style"
+            app:layout_constraintLeft_toLeftOf="parent"
+            app:layout_constraintRight_toRightOf="parent"
+            app:layout_constraintTop_toBottomOf="@id/sort_by_options" />
+
+        <io.github.mattpvaughn.chronicle.views.FlowableRadioGroup
+            android:id="@+id/view_styles"
+            android:layout_width="0dp"
+            android:layout_height="wrap_content"
+            app:itemSpacing="@dimen/margin_small"
+            app:layout_constraintLeft_toLeftOf="parent"
+            app:layout_constraintRight_toRightOf="parent"
+            app:layout_constraintTop_toBottomOf="@id/view_style_title"
+            app:lineSpacing="@dimen/margin_small">
+
+            <com.google.android.material.radiobutton.MaterialRadioButton
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:tag="@string/key_view_style_cover_grid"
+                android:text="@string/view_style_book_cover" />
+
+            <com.google.android.material.radiobutton.MaterialRadioButton
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:tag="@string/key_view_style_details"
+                android:text="@string/view_style_cover_and_text_list" />
+
+            <com.google.android.material.radiobutton.MaterialRadioButton
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:tag="@string/key_view_style_text_only"
+                android:text="@string/view_style_text_list" />
+
+        </io.github.mattpvaughn.chronicle.views.FlowableRadioGroup>
+
+
+        <!-- TODO: add view by folder, view by author, etc.-->
+        <!--                <androidx.appcompat.widget.AppCompatTextView-->
+        <!--                    android:id="@+id/view_by"-->
+        <!--                    style="@style/TextAppearance.Body1"-->
+        <!--                    android:layout_width="wrap_content"-->
+        <!--                    android:layout_height="wrap_content"-->
+        <!--                    android:paddingTop="@dimen/margin_normal"-->
+        <!--                    android:paddingBottom="@dimen/margin_normal"-->
+        <!--                    android:text="@string/view_by"-->
+        <!--                    app:layout_constraintLeft_toLeftOf="parent"-->
+        <!--                    app:layout_constraintTop_toBottomOf="@id/sort_by_options" />-->
+
+        <!--                <io.github.mattpvaughn.chronicle.views.FlowableRadioGroup-->
+        <!--                    android:id="@+id/view_by_options"-->
+        <!--                    android:layout_width="0dp"-->
+        <!--                    android:layout_height="wrap_content"-->
+        <!--                    app:itemSpacing="@dimen/margin_small"-->
+        <!--                    app:layout_constraintLeft_toLeftOf="parent"-->
+        <!--                    app:layout_constraintRight_toRightOf="parent"-->
+        <!--                    app:layout_constraintTop_toBottomOf="@id/view_by"-->
+        <!--                    app:lineSpacing="@dimen/margin_small">-->
+
+        <!--                    <com.google.android.material.radiobutton.MaterialRadioButton-->
+        <!--                        android:layout_width="wrap_content"-->
+        <!--                        android:layout_height="wrap_content"-->
+        <!--                        android:tag="@string/key_view_by_book"-->
+        <!--                        android:text="@string/view_by_book" />-->
+
+        <!--                    <com.google.android.material.radiobutton.MaterialRadioButton-->
+        <!--                        android:layout_width="wrap_content"-->
+        <!--                        android:layout_height="wrap_content"-->
+        <!--                        android:tag="@string/key_view_by_author"-->
+        <!--                        android:text="@string/view_by_author" />-->
+
+        <!--                    <com.google.android.material.radiobutton.MaterialRadioButton-->
+        <!--                        android:layout_width="wrap_content"-->
+        <!--                        android:layout_height="wrap_content"-->
+        <!--                        android:tag="@string/key_view_by_folder"-->
+        <!--                        android:text="@string/view_by_folder" />-->
+
+        <!--                    <com.google.android.material.radiobutton.MaterialRadioButton-->
+        <!--                        android:layout_width="wrap_content"-->
+        <!--                        android:layout_height="wrap_content"-->
+        <!--                        android:tag="@string/key_view_by_collection"-->
+        <!--                        android:text="@string/view_by_collection" />-->
+
+        <!--                </io.github.mattpvaughn.chronicle.views.FlowableRadioGroup>-->
+
+    </androidx.constraintlayout.widget.ConstraintLayout>
+</layout>
Index: app/schemas/io.github.mattpvaughn.chronicle.data.local.BookDatabase/7.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/schemas/io.github.mattpvaughn.chronicle.data.local.BookDatabase/7.json b/app/schemas/io.github.mattpvaughn.chronicle.data.local.BookDatabase/7.json
new file mode 100755
--- /dev/null	(date 1619409944169)
+++ b/app/schemas/io.github.mattpvaughn.chronicle.data.local.BookDatabase/7.json	(date 1619409944169)
@@ -0,0 +1,148 @@
+{
+  "formatVersion": 1,
+  "database": {
+    "version": 7,
+    "identityHash": "68fa8cecb100280f703df154fbfaffc6",
+    "entities": [
+      {
+        "tableName": "Audiobook",
+        "createSql": "CREATE TABLE IF NOT EXISTS `${TABLE_NAME}` (`id` INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, `serverId` INTEGER NOT NULL, `source` INTEGER NOT NULL, `title` TEXT NOT NULL, `titleSort` TEXT NOT NULL, `author` TEXT NOT NULL, `thumb` TEXT NOT NULL, `parentId` INTEGER NOT NULL, `genre` TEXT NOT NULL, `summary` TEXT NOT NULL, `addedAt` INTEGER NOT NULL, `updatedAt` INTEGER NOT NULL, `lastViewedAt` INTEGER NOT NULL, `duration` INTEGER NOT NULL, `isCached` INTEGER NOT NULL, `progress` INTEGER NOT NULL, `favorited` INTEGER NOT NULL, `viewedLeafCount` INTEGER NOT NULL, `leafCount` INTEGER NOT NULL, `viewCount` INTEGER NOT NULL)",
+        "fields": [
+          {
+            "fieldPath": "id",
+            "columnName": "id",
+            "affinity": "INTEGER",
+            "notNull": true
+          },
+          {
+            "fieldPath": "serverId",
+            "columnName": "serverId",
+            "affinity": "INTEGER",
+            "notNull": true
+          },
+          {
+            "fieldPath": "source",
+            "columnName": "source",
+            "affinity": "INTEGER",
+            "notNull": true
+          },
+          {
+            "fieldPath": "title",
+            "columnName": "title",
+            "affinity": "TEXT",
+            "notNull": true
+          },
+          {
+            "fieldPath": "titleSort",
+            "columnName": "titleSort",
+            "affinity": "TEXT",
+            "notNull": true
+          },
+          {
+            "fieldPath": "author",
+            "columnName": "author",
+            "affinity": "TEXT",
+            "notNull": true
+          },
+          {
+            "fieldPath": "thumb",
+            "columnName": "thumb",
+            "affinity": "TEXT",
+            "notNull": true
+          },
+          {
+            "fieldPath": "parentId",
+            "columnName": "parentId",
+            "affinity": "INTEGER",
+            "notNull": true
+          },
+          {
+            "fieldPath": "genre",
+            "columnName": "genre",
+            "affinity": "TEXT",
+            "notNull": true
+          },
+          {
+            "fieldPath": "summary",
+            "columnName": "summary",
+            "affinity": "TEXT",
+            "notNull": true
+          },
+          {
+            "fieldPath": "addedAt",
+            "columnName": "addedAt",
+            "affinity": "INTEGER",
+            "notNull": true
+          },
+          {
+            "fieldPath": "updatedAt",
+            "columnName": "updatedAt",
+            "affinity": "INTEGER",
+            "notNull": true
+          },
+          {
+            "fieldPath": "lastViewedAt",
+            "columnName": "lastViewedAt",
+            "affinity": "INTEGER",
+            "notNull": true
+          },
+          {
+            "fieldPath": "duration",
+            "columnName": "duration",
+            "affinity": "INTEGER",
+            "notNull": true
+          },
+          {
+            "fieldPath": "isCached",
+            "columnName": "isCached",
+            "affinity": "INTEGER",
+            "notNull": true
+          },
+          {
+            "fieldPath": "progress",
+            "columnName": "progress",
+            "affinity": "INTEGER",
+            "notNull": true
+          },
+          {
+            "fieldPath": "favorited",
+            "columnName": "favorited",
+            "affinity": "INTEGER",
+            "notNull": true
+          },
+          {
+            "fieldPath": "viewedLeafCount",
+            "columnName": "viewedLeafCount",
+            "affinity": "INTEGER",
+            "notNull": true
+          },
+          {
+            "fieldPath": "leafCount",
+            "columnName": "leafCount",
+            "affinity": "INTEGER",
+            "notNull": true
+          },
+          {
+            "fieldPath": "viewCount",
+            "columnName": "viewCount",
+            "affinity": "INTEGER",
+            "notNull": true
+          }
+        ],
+        "primaryKey": {
+          "columnNames": [
+            "id"
+          ],
+          "autoGenerate": true
+        },
+        "indices": [],
+        "foreignKeys": []
+      }
+    ],
+    "views": [],
+    "setupQueries": [
+      "CREATE TABLE IF NOT EXISTS room_master_table (id INTEGER PRIMARY KEY,identity_hash TEXT)",
+      "INSERT OR REPLACE INTO room_master_table (id,identity_hash) VALUES(42, '68fa8cecb100280f703df154fbfaffc6')"
+    ]
+  }
+}
\ No newline at end of file
Index: app/src/main/res/drawable/ic_plex_library_white.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/res/drawable/ic_plex_library_white.xml b/app/src/main/res/drawable/ic_plex_library_white.xml
new file mode 100755
--- /dev/null	(date 1601499673212)
+++ b/app/src/main/res/drawable/ic_plex_library_white.xml	(date 1601499673212)
@@ -0,0 +1,10 @@
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="24dp"
+    android:height="24dp"
+    android:viewportWidth="24"
+    android:viewportHeight="24">
+  <path
+      android:pathData="m4.3841,2.2082c-1.1968,0 -2.176,0.9792 -2.176,2.176V19.6159c0,1.1968 0.9792,2.176 2.176,2.176H19.6159c1.1968,0 2.176,-0.9792 2.176,-2.176V4.3841c0,-1.1968 -0.9792,-2.176 -2.176,-2.176zM7.9456,5.4381H11.8151L16.0544,12 11.8151,18.5619H7.9456L12.0871,12Z"
+      android:strokeWidth="1.08798"
+      android:fillColor="#ffffff"/>
+</vector>
Index: app/schemas/io.github.mattpvaughn.chronicle.data.local.TrackDatabase/6.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/schemas/io.github.mattpvaughn.chronicle.data.local.TrackDatabase/6.json b/app/schemas/io.github.mattpvaughn.chronicle.data.local.TrackDatabase/6.json
new file mode 100755
--- /dev/null	(date 1619391357501)
+++ b/app/schemas/io.github.mattpvaughn.chronicle.data.local.TrackDatabase/6.json	(date 1619391357501)
@@ -0,0 +1,154 @@
+{
+  "formatVersion": 1,
+  "database": {
+    "version": 6,
+    "identityHash": "39704d8012a17387a24858ff6fea3efa",
+    "entities": [
+      {
+        "tableName": "MediaItemTrack",
+        "createSql": "CREATE TABLE IF NOT EXISTS `${TABLE_NAME}` (`id` INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, `serverId` INTEGER NOT NULL, `parentServerId` INTEGER NOT NULL, `title` TEXT NOT NULL, `playQueueItemID` INTEGER NOT NULL, `thumb` TEXT, `index` INTEGER NOT NULL, `discNumber` INTEGER NOT NULL, `duration` INTEGER NOT NULL, `media` TEXT NOT NULL, `album` TEXT NOT NULL, `artist` TEXT NOT NULL, `genre` TEXT NOT NULL, `cached` INTEGER NOT NULL, `artwork` TEXT, `viewCount` INTEGER NOT NULL, `progress` INTEGER NOT NULL, `lastViewedAt` INTEGER NOT NULL, `updatedAt` INTEGER NOT NULL, `size` INTEGER NOT NULL, `source` INTEGER NOT NULL)",
+        "fields": [
+          {
+            "fieldPath": "id",
+            "columnName": "id",
+            "affinity": "INTEGER",
+            "notNull": true
+          },
+          {
+            "fieldPath": "serverId",
+            "columnName": "serverId",
+            "affinity": "INTEGER",
+            "notNull": true
+          },
+          {
+            "fieldPath": "parentServerId",
+            "columnName": "parentServerId",
+            "affinity": "INTEGER",
+            "notNull": true
+          },
+          {
+            "fieldPath": "title",
+            "columnName": "title",
+            "affinity": "TEXT",
+            "notNull": true
+          },
+          {
+            "fieldPath": "playQueueItemID",
+            "columnName": "playQueueItemID",
+            "affinity": "INTEGER",
+            "notNull": true
+          },
+          {
+            "fieldPath": "thumb",
+            "columnName": "thumb",
+            "affinity": "TEXT",
+            "notNull": false
+          },
+          {
+            "fieldPath": "index",
+            "columnName": "index",
+            "affinity": "INTEGER",
+            "notNull": true
+          },
+          {
+            "fieldPath": "discNumber",
+            "columnName": "discNumber",
+            "affinity": "INTEGER",
+            "notNull": true
+          },
+          {
+            "fieldPath": "duration",
+            "columnName": "duration",
+            "affinity": "INTEGER",
+            "notNull": true
+          },
+          {
+            "fieldPath": "media",
+            "columnName": "media",
+            "affinity": "TEXT",
+            "notNull": true
+          },
+          {
+            "fieldPath": "album",
+            "columnName": "album",
+            "affinity": "TEXT",
+            "notNull": true
+          },
+          {
+            "fieldPath": "artist",
+            "columnName": "artist",
+            "affinity": "TEXT",
+            "notNull": true
+          },
+          {
+            "fieldPath": "genre",
+            "columnName": "genre",
+            "affinity": "TEXT",
+            "notNull": true
+          },
+          {
+            "fieldPath": "cached",
+            "columnName": "cached",
+            "affinity": "INTEGER",
+            "notNull": true
+          },
+          {
+            "fieldPath": "artwork",
+            "columnName": "artwork",
+            "affinity": "TEXT",
+            "notNull": false
+          },
+          {
+            "fieldPath": "viewCount",
+            "columnName": "viewCount",
+            "affinity": "INTEGER",
+            "notNull": true
+          },
+          {
+            "fieldPath": "progress",
+            "columnName": "progress",
+            "affinity": "INTEGER",
+            "notNull": true
+          },
+          {
+            "fieldPath": "lastViewedAt",
+            "columnName": "lastViewedAt",
+            "affinity": "INTEGER",
+            "notNull": true
+          },
+          {
+            "fieldPath": "updatedAt",
+            "columnName": "updatedAt",
+            "affinity": "INTEGER",
+            "notNull": true
+          },
+          {
+            "fieldPath": "size",
+            "columnName": "size",
+            "affinity": "INTEGER",
+            "notNull": true
+          },
+          {
+            "fieldPath": "source",
+            "columnName": "source",
+            "affinity": "INTEGER",
+            "notNull": true
+          }
+        ],
+        "primaryKey": {
+          "columnNames": [
+            "id"
+          ],
+          "autoGenerate": true
+        },
+        "indices": [],
+        "foreignKeys": []
+      }
+    ],
+    "views": [],
+    "setupQueries": [
+      "CREATE TABLE IF NOT EXISTS room_master_table (id INTEGER PRIMARY KEY,identity_hash TEXT)",
+      "INSERT OR REPLACE INTO room_master_table (id,identity_hash) VALUES(42, '39704d8012a17387a24858ff6fea3efa')"
+    ]
+  }
+}
\ No newline at end of file
Index: app/src/main/res/layout/fragment_source_manager.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/res/layout/fragment_source_manager.xml b/app/src/main/res/layout/fragment_source_manager.xml
new file mode 100755
--- /dev/null	(date 1601493194566)
+++ b/app/src/main/res/layout/fragment_source_manager.xml	(date 1601493194566)
@@ -0,0 +1,127 @@
+<?xml version="1.0" encoding="utf-8"?>
+<layout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto"
+    xmlns:tools="http://schemas.android.com/tools">
+
+    <data>
+
+        <variable
+            name="viewModel"
+            type="io.github.mattpvaughn.chronicle.features.sources.SourceManagerViewModel" />
+
+        <import type="android.view.View" />
+    </data>
+
+    <androidx.coordinatorlayout.widget.CoordinatorLayout
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:background="@color/colorPrimaryDark"
+        tools:context=".features.sources.SourceManagerFragment">
+
+        <androidx.constraintlayout.widget.ConstraintLayout
+            android:layout_width="match_parent"
+            android:layout_height="match_parent">
+
+            <TextView
+                android:id="@+id/choose_source_title"
+                style="@style/TextAppearance.Title"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_marginLeft="@dimen/screen_horizontal_padding"
+                android:layout_marginTop="@dimen/app_bar_height"
+                android:layout_marginRight="@dimen/screen_horizontal_padding"
+                android:text="@string/sources"
+                app:layout_constraintLeft_toLeftOf="parent"
+                app:layout_constraintTop_toTopOf="parent" />
+
+            <androidx.recyclerview.widget.RecyclerView
+                android:id="@+id/source_list"
+                android:layout_width="match_parent"
+                android:layout_height="0dp"
+                android:layout_marginTop="@dimen/spacing_normal"
+                android:layout_marginBottom="@dimen/screen_vertical_padding"
+                android:visibility="@{!viewModel.sources.empty  ? View.VISIBLE : View.GONE}"
+                app:layoutManager="androidx.recyclerview.widget.LinearLayoutManager"
+                app:layout_constraintBottom_toBottomOf="parent"
+                app:layout_constraintLeft_toLeftOf="parent"
+                app:layout_constraintRight_toRightOf="parent"
+                app:layout_constraintTop_toBottomOf="@id/choose_source_title"
+                app:sources="@{viewModel.sources}"
+                tools:listitem="@layout/list_item_source" />
+
+            <TextView
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:text="@string/no_sources_found"
+                android:visibility="@{viewModel.sources.empty  ? View.VISIBLE : View.GONE}"
+                app:layout_constraintBottom_toBottomOf="parent"
+                app:layout_constraintLeft_toLeftOf="parent"
+                app:layout_constraintRight_toRightOf="parent"
+                app:layout_constraintTop_toBottomOf="@id/choose_source_title" />
+
+        </androidx.constraintlayout.widget.ConstraintLayout>
+
+        <com.google.android.material.floatingactionbutton.FloatingActionButton
+            android:id="@+id/add_new_source"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_gravity="bottom|right"
+            android:layout_margin="@dimen/margin_normal"
+            android:src="@drawable/ic_add_no_outline"
+            app:tint="@color/icon" />
+
+        <androidx.constraintlayout.widget.ConstraintLayout
+            android:id="@+id/source_editor"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:background="@color/panelBackground"
+            android:elevation="8dp"
+            android:paddingLeft="@dimen/screen_horizontal_padding"
+            android:paddingTop="@dimen/margin_large"
+            android:paddingRight="@dimen/screen_horizontal_padding"
+            android:paddingBottom="@dimen/margin_large"
+            app:behavior_fitToContents="true"
+            app:behavior_hideable="true"
+            app:behavior_skipCollapsed="true"
+            app:layout_behavior="com.google.android.material.bottomsheet.BottomSheetBehavior">
+
+            <ImageView
+                android:id="@+id/source_type_icon"
+                android:layout_width="@dimen/list_icon_size"
+                android:layout_height="@dimen/list_icon_size"
+                android:contentDescription="@{viewModel.source.type}"
+                android:src="@{viewModel.source.icon}"
+                app:layout_constraintLeft_toLeftOf="parent"
+                app:layout_constraintTop_toTopOf="parent" />
+
+            <TextView
+                android:id="@+id/library_name"
+                style="@style/TextAppearance.Body1"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_marginLeft="@dimen/spacing_normal"
+                android:text="@{ viewModel.source.name }"
+                app:layout_constraintBottom_toBottomOf="@id/source_type_icon"
+                app:layout_constraintLeft_toRightOf="@id/source_type_icon"
+                app:layout_constraintTop_toTopOf="@id/source_type_icon"
+                tools:text="Audiobooks" />
+
+            <com.google.android.material.button.MaterialButton
+                android:id="@+id/remove_source"
+                android:layout_marginTop="@dimen/spacing_normal"
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:backgroundTint="@color/buttonDelete"
+                android:drawableStart="@drawable/ic_delete"
+                android:onClick="@{() -> viewModel.removeSource()}"
+                android:text="@string/delete"
+                android:textColor="@color/textPrimary"
+                app:layout_constraintBottom_toBottomOf="parent"
+                app:layout_constraintLeft_toLeftOf="parent"
+                app:layout_constraintRight_toRightOf="parent"
+                app:layout_constraintTop_toBottomOf="@id/source_type_icon" />
+
+        </androidx.constraintlayout.widget.ConstraintLayout>
+
+    </androidx.coordinatorlayout.widget.CoordinatorLayout>
+</layout>
\ No newline at end of file
Index: app/src/main/java/io/github/mattpvaughn/chronicle/data/sources/MediaSourceFactory.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/io/github/mattpvaughn/chronicle/data/sources/MediaSourceFactory.kt b/app/src/main/java/io/github/mattpvaughn/chronicle/data/sources/MediaSourceFactory.kt
new file mode 100755
--- /dev/null	(date 1601391975349)
+++ b/app/src/main/java/io/github/mattpvaughn/chronicle/data/sources/MediaSourceFactory.kt	(date 1601391975349)
@@ -0,0 +1,33 @@
+package io.github.mattpvaughn.chronicle.data.sources
+
+import android.content.Context
+import com.squareup.moshi.Moshi
+import io.github.mattpvaughn.chronicle.data.sources.demo.DemoMediaSource
+import io.github.mattpvaughn.chronicle.data.sources.plex.PlexLibrarySource
+import io.github.mattpvaughn.chronicle.injection.components.AppComponent.Companion.USER_AGENT
+import okhttp3.logging.HttpLoggingInterceptor
+import javax.inject.Inject
+import javax.inject.Named
+import javax.inject.Singleton
+
+/** Class containing information needed to instantiate any [MediaSource] child */
+@Singleton
+class MediaSourceFactory @Inject constructor(
+    private val applicationContext: Context,
+    private val loggingInterceptor: HttpLoggingInterceptor,
+    private val moshi: Moshi,
+    @Named(USER_AGENT)
+    private val userAgent: String
+) {
+    fun create(id: Long, type: String): MediaSource {
+        return when (type) {
+            DemoMediaSource.TAG -> {
+                DemoMediaSource(id, applicationContext)
+            }
+            PlexLibrarySource.TAG -> {
+                PlexLibrarySource(id, applicationContext, loggingInterceptor, moshi)
+            }
+            else -> TODO("Type not yet supported")
+        }
+    }
+}
\ No newline at end of file
Index: app/src/main/java/io/github/mattpvaughn/chronicle/features/login/AddSourceViewModel.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/io/github/mattpvaughn/chronicle/features/login/AddSourceViewModel.kt b/app/src/main/java/io/github/mattpvaughn/chronicle/features/login/AddSourceViewModel.kt
new file mode 100755
--- /dev/null	(date 1601391975369)
+++ b/app/src/main/java/io/github/mattpvaughn/chronicle/features/login/AddSourceViewModel.kt	(date 1601391975369)
@@ -0,0 +1,116 @@
+package io.github.mattpvaughn.chronicle.features.login
+
+import android.content.SharedPreferences
+import android.net.Uri
+import androidx.lifecycle.*
+import io.github.mattpvaughn.chronicle.application.Injector
+import io.github.mattpvaughn.chronicle.data.local.PrefsRepo
+import io.github.mattpvaughn.chronicle.data.sources.MediaSourceFactory
+import io.github.mattpvaughn.chronicle.data.sources.SourceManager
+import io.github.mattpvaughn.chronicle.data.sources.demo.DemoMediaSource
+import io.github.mattpvaughn.chronicle.data.sources.plex.PlexLibrarySource
+import io.github.mattpvaughn.chronicle.data.sources.plex.model.OAuthResponse
+import io.github.mattpvaughn.chronicle.navigation.Navigator
+import io.github.mattpvaughn.chronicle.util.BooleanPreferenceLiveData
+import io.github.mattpvaughn.chronicle.util.Event
+import io.github.mattpvaughn.chronicle.util.postEvent
+import kotlinx.coroutines.launch
+import javax.inject.Inject
+import kotlin.time.ExperimentalTime
+
+
+class AddSourceViewModel(
+    private val sourceManager: SourceManager,
+    sharedPrefs: SharedPreferences,
+    private val navigator: Navigator,
+    private val mediaSourceFactory: MediaSourceFactory,
+    private val potentialPlexSource: PlexLibrarySource
+) : ViewModel() {
+
+    class Factory @Inject constructor(
+        private val sharedPrefs: SharedPreferences,
+        private val sourceManager: SourceManager,
+        private val navigator: Navigator,
+        private val mediaSourceFactory: MediaSourceFactory
+    ) : ViewModelProvider.Factory {
+
+        lateinit var potentialPlexSource: PlexLibrarySource
+
+        @Suppress("UNCHECKED_CAST")
+        override fun <T : ViewModel> create(modelClass: Class<T>): T {
+            check(this::potentialPlexSource.isInitialized) { "Source must be provided!" }
+            if (modelClass.isAssignableFrom(AddSourceViewModel::class.java)) {
+                return AddSourceViewModel(
+                    sourceManager,
+                    sharedPrefs,
+                    navigator,
+                    mediaSourceFactory,
+                    potentialPlexSource
+                ) as T
+            }
+            throw IllegalArgumentException("Unknown ViewHolder class")
+        }
+    }
+
+    private var _authEvent = MutableLiveData<Event<OAuthResponse?>>()
+    val authEvent: LiveData<Event<OAuthResponse?>>
+        get() = _authEvent
+
+    private var _messageForUser = MutableLiveData<Event<String>>()
+    val messageForUser: LiveData<Event<String>>
+        get() = _messageForUser
+
+    private var hasLaunched = false
+
+    private var _isLoading = MutableLiveData<Boolean>(false)
+    val isLoading: LiveData<Boolean>
+        get() = _isLoading
+
+    val allowAuto = BooleanPreferenceLiveData(PrefsRepo.KEY_ALLOW_AUTO, false, sharedPrefs)
+
+    fun loginWithPlexOAuth() {
+        viewModelScope.launch(Injector.get().unhandledExceptionHandler()) {
+            val pin = potentialPlexSource.postOAuthPin()
+            _authEvent.postEvent(pin)
+        }
+    }
+
+    fun makePlexOAuthLoginUrl(id: String, code: String): Uri {
+        return potentialPlexSource.makeOAuthUrl(id, code)
+    }
+
+    /** Whether the custom tab has been launched to login */
+    fun setLaunched(b: Boolean) {
+        hasLaunched = b
+    }
+
+    @ExperimentalTime
+    fun addDemoLibrary() {
+        val demoMediaSource = DemoMediaSource(
+            sourceManager.generateUniqueId(),
+            Injector.get().applicationContext()
+        )
+        sourceManager.addSource(demoMediaSource)
+        demoMediaSource.setup(navigator)
+    }
+
+    fun checkForAccess() {
+        if (hasLaunched) {
+            viewModelScope.launch(Injector.get().unhandledExceptionHandler()) {
+                // Check for access, if the login repo gains access, then PlexLibrary will handle
+                // navigation until login
+                sourceManager.addSource(
+                    mediaSourceFactory.create(
+                        sourceManager.generateUniqueId(),
+                        PlexLibrarySource.TAG
+                    )
+                )
+                val result = potentialPlexSource.checkForOAuthAccessToken(navigator)
+                val errorMessage = result.exceptionOrNull()?.message
+                if (errorMessage != null) {
+                    _messageForUser.postEvent(errorMessage)
+                }
+            }
+        }
+    }
+}
Index: app/src/main/res/layout/list_item_source.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/res/layout/list_item_source.xml b/app/src/main/res/layout/list_item_source.xml
new file mode 100755
--- /dev/null	(date 1601480681517)
+++ b/app/src/main/res/layout/list_item_source.xml	(date 1601480681517)
@@ -0,0 +1,49 @@
+<?xml version="1.0" encoding="utf-8"?>
+<layout xmlns:app="http://schemas.android.com/apk/res-auto"
+    xmlns:tools="http://schemas.android.com/tools">
+
+    <data>
+
+        <variable
+            name="source"
+            type="io.github.mattpvaughn.chronicle.data.sources.MediaSource" />
+
+        <variable
+            name="clickListener"
+            type="io.github.mattpvaughn.chronicle.features.sources.SourceClickListener" />
+
+    </data>
+
+    <androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
+        android:layout_width="match_parent"
+        android:layout_height="@dimen/list_item_height"
+        android:paddingLeft="@dimen/screen_horizontal_padding"
+        android:paddingRight="@dimen/screen_horizontal_padding"
+        android:background="?android:attr/selectableItemBackground"
+        android:onClick="@{() -> clickListener.onClick(source)}"
+        android:orientation="vertical">
+
+        <ImageView
+            android:id="@+id/source_type_icon"
+            android:layout_width="@dimen/list_icon_size"
+            android:layout_height="@dimen/list_icon_size"
+            android:layout_marginLeft="@dimen/screen_horizontal_padding"
+            android:contentDescription="@{source.name}"
+            android:src="@{source.icon}"
+            app:layout_constraintBottom_toBottomOf="parent"
+            app:layout_constraintLeft_toLeftOf="parent"
+            app:layout_constraintTop_toTopOf="parent" />
+
+        <TextView
+            android:id="@+id/library_name"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_marginLeft="@dimen/keyline_x_offset"
+            android:text="@{ source.name }"
+            app:layout_constraintBottom_toBottomOf="parent"
+            app:layout_constraintLeft_toLeftOf="parent"
+            app:layout_constraintTop_toTopOf="parent"
+            tools:text="Audiobooks" />
+
+    </androidx.constraintlayout.widget.ConstraintLayout>
+</layout>
